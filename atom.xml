<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>init 1</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mooyoul.github.io/"/>
  <updated>2017-02-19T22:42:18.000Z</updated>
  <id>https://mooyoul.github.io/</id>
  
  <author>
    <name>MooYeol Prescott Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js request 패키지의 망가진 Stream 고치기</title>
    <link href="https://mooyoul.github.io/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/"/>
    <id>https://mooyoul.github.io/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/</id>
    <published>2017-02-17T18:37:01.000Z</published>
    <updated>2017-02-19T22:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/request.png" alt="request" title="request">
<h1 id="Node-js-request-패키지의-망가진-Stream-고치기"><a href="#Node-js-request-패키지의-망가진-Stream-고치기" class="headerlink" title="Node.js request 패키지의 망가진 Stream 고치기"></a>Node.js request 패키지의 망가진 Stream 고치기</h1><p>얼마 전 사이드잡으로 진행하고 있는 서비스에서 소셜 계정으로 로그인한 아바타 이미지(프로필 사진)가 표시되지 않는 일이 발생했다.</p>
<p>그동안 해당 서비스에서는 아바타 이미지를 스토리지에 저장하지 않고 각 SNS 서비스에서 제공하는 아바타 이미지의 URL을 가져다가 썼는데,<br>Facebook을 비롯한 일부 서비스의 경우 해당 이미지 URL에 access control을 위한 policy가 붙어있었다.</p>
<p>AWS의 CloudFront나 Akamai 같은 CDN의 경우 언제까지 파일에 접근이 가능한지를 Policy를 통해 제어할 수 있는데,<br>아바타 이미지의 URL에 그것이 붙어있었던 것.</p>
<p>Graph API로 대체를 할까 고민하다가, <a href="http://stackoverflow.com/questions/30477877/facebook-image-url-gets-expired" target="_blank" rel="external">이런 의견</a>도 있고 해서 그냥 로그인할때마다 S3에 올리고 (있으면 덮어쓰고) CloudFront를 통해 서빙을 하는 방향으로 결정하고,<br>아바타 이미지 URL을 내려받고 S3에 해당 이미지를 저장하도록 아래와 같은 스니펫을 작성했다.</p>
<script src="https://gist.github.com/mooyoul/0296599f7a25683251ae68eec2ee1444.js"></script>

<p>뭐 별 문제 없으리라 생각했다.</p>
<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/first-upload.png" alt="네이버 favicon으로 테스트" title="네이버 favicon으로 테스트">
<p>업로드도 잘 된 것 같았다.</p>
<p>그런데……. 막상 S3에서 확인해보니….</p>
<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/zero-bytes.png" alt="?!?!?!!?" title="?!?!?!!?">
<p>읭??????? <strong>업로드 한 객체의 크기가 0바이트로 뜬다?!?!?!?</strong></p>
<p>혹시나해서 <code>s3.upload</code>에 전달하는 <code>Body</code> property를 Readable Stream 대신 Buffer로 던져보기로 했다.</p>
<script src="https://gist.github.com/mooyoul/3d4d0e9740cb0195b0483e1be5225c52.js"></script>

<p>위 스니펫을 작성하고 다시 동일하게 테스트를 진행했다.</p>
<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/second-upload.png" alt="Buffer로 다시 업로드 시도" title="Buffer로 다시 업로드 시도">
<p>업로드는 잘 되었다고 떴고, 다시 업로드된 객체를 조회해보면…</p>
<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/such-bytes.png" alt="오예" title="오예">
<p>S3에 제대로 파일이 올라간다!!!</p>
<p>여기서 Buffer를 쓰는 방법을 택하고 포기할 수 있었지만,<br>만약 업로드 할 바이너리가 큰 경우, 동시에 들어오는 로그인 요청이 많아지는 경우를 생각하면 찝찝해서 더 파보기로 했다.<br>메모리는 소중하니까… ㅠㅠ</p>
<h2 id="어디서-잘못된건지-찾기"><a href="#어디서-잘못된건지-찾기" class="headerlink" title="어디서 잘못된건지 찾기"></a>어디서 잘못된건지 찾기</h2><p>이제 어디서 잘못된건지 검증해야하는 포인트가 조금 좁혀졌다.</p>
<p>1) AWS SDK에서 <code>s3.upload</code>를 통해 파일을 업로드 할 때, Stream을 사용할 수 없거나<br>2) AWS SDK로 전달되는 Stream에 문제가 있거나</p>
<p>둘 중 하나일 것이다.</p>
<h3 id="AWS-SDK"><a href="#AWS-SDK" class="headerlink" title="AWS SDK"></a>AWS SDK</h3><p>AWS SDK에서 <code>s3.upload</code>를 통해 파일을 업로드할 때, Stream을 사용할 수 없는지 검증해야 했다.<br>근데 애초에 내가 Stream을 썼던 것은, <a href="http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#upload-property" target="_blank" rel="external">AWS SDK documentation에서 Stream을 전달할 수 있다</a>고 나왔기 때문이다.</p>
<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/aws-sdk-s3-upload-doc.png" alt="심지어 예제도 Stream을 쓰는데?" title="심지어 예제도 Stream을 쓰는데?">
<p>다시 한번 SDK 문서를 체크해봐도 Readable Stream을 쓸 수 있다고 나와있다. 심지어 예제도 Readable Stream을 쓴다.</p>
<p>정말 혹~~시라도 문서가 잘못되어있는 경우를 생각하기 위해, AWS SDK에서 Stream을 받을 수 있는지 없는지 검증해보기로 했다.<br>동시에 2)를 검증할 수도 있기도 하고…</p>
<h3 id="request의-response"><a href="#request의-response" class="headerlink" title="request의 response"></a>request의 <code>response</code></h3><p>request 쪽에서 <code>response</code> event로 전달받은 <code>response</code> readable stream에 문제가 있는지 검증을 하기 위해,<br><a href="https://nodejs.org/api/fs.html#fs_fs_createreadstream_path_options" target="_blank" rel="external"><code>fs.createReadStream</code></a>로 로컬 파일을 Readable stream으로 가져와 S3로 업로드를 시도해보기로 했다.</p>
<script src="https://gist.github.com/mooyoul/550326977415d9707fa6dccba9c0b634.js"></script>

<p>그리고 테스트를 해보면…</p>
<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/file-stream-upload.png" alt="file stream으로 s3 업로드" title="file stream으로 s3 업로드">
<p>잘 올라가는것을 확인할 수 있다.</p>
<p>일단 여기서 AWS SDK이 Stream을 지원한다는건 검증한 셈이니, request쪽에서 <code>response</code> event를 통해 전달한 <code>response</code> stream에 문제가 있을거라고 예측할 수 있다.</p>
<p>이를 검증하기 위해, 이번에는 <a href="https://nodejs.org/api/http.html#http_http_request_options_callback" target="_blank" rel="external"><code>http.request</code></a>의 shortcut인 <a href="https://nodejs.org/api/http.html#http_http_get_options_callback" target="_blank" rel="external"><code>http.get</code></a>을 통해 s3로 업로드를 시도했다.</p>
<script src="https://gist.github.com/mooyoul/27599bba52fb49eac6afdd65d960b93d.js"></script>

<p>역시 위 스니펫으로 테스트해보면…</p>
<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/http-request-upload.png" alt="잘된다!" title="잘된다!">
<p>잘 되는것을 확인할 수 있다.<br>어쩄거나 <code>request</code> 패키지쪽에서 넘어오는 stream에 문제가 있는 것 같은데…</p>
<h2 id="점점-더-미궁속으로"><a href="#점점-더-미궁속으로" class="headerlink" title="점점 더 미궁속으로"></a>점점 더 미궁속으로</h2><p>이것저것 테스트를 더 진행하던 와중에, 아래 스니펫이 정상 동작하는것을 확인하고 이슈는 더 미궁속으로 빠지기 시작했다.</p>
<p>분명 <code>request</code> 쪽에서 넘겨주는 <code>response</code> stream에 문제가 있었던 것 같은데.<br>이슈가 발생하는 이전 스니펫에서 다운로드 받은 파일을 s3가 아닌 로컬 파일로 쓰게 하면 잘 되었기 때문이다.</p>
<script src="https://gist.github.com/mooyoul/0b6fb0bfdf70b9194d5b15184c62cd63.js"></script>

<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/write-to-local-file.png" alt="로컬 파일로 기록" title="로컬 파일로 기록">
<p>도대체 무엇이 문제인걸까????</p>
<h2 id="우연히-발견한-또-다른-재현-방법"><a href="#우연히-발견한-또-다른-재현-방법" class="headerlink" title="우연히 발견한 또 다른 재현 방법"></a>우연히 발견한 또 다른 재현 방법</h2><p>멘탈이 반쯤 나간 상태로 이것 저것 케이스를 더 만들어서 테스트를 해보다가, </p>
<p>우연히 아래처럼 <code>response</code> stream을 다른 stream으로 pipe하는것을 지연했더니,<br><code>s3.upload</code>를 통해 업로드를 했던것과 동일하게 0바이트로 파일을 기록한 결과가 나왔다!</p>
<script src="https://gist.github.com/mooyoul/22c30bc04aff53190564c63a6484da1e.js"></script>

<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/write-to-local-file-delayed.png" alt="지연된 pipe 후 0바이트로 파일이 기록된 모습" title="지연된 pipe 후 0바이트로 파일이 기록된 모습">
<p>여기서 request 대신 아까처럼 <a href="https://nodejs.org/api/http.html#http_http_get_options_callback" target="_blank" rel="external"><code>http.get</code></a>을 통해 pipe를 하면..</p>
<script src="https://gist.github.com/mooyoul/cdfc66bf0613daa77022e84e92b1899e.js"></script>

<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/write-to-local-file-delayed-http.png" alt="오예!" title="오예!">
<p>이쪽은 잘 되는것을 확인할 수 있다.</p>
<p>자, 이제 무엇이 문제인지 어느정도 추측해볼 수 있다.</p>
<p>이번에 세운 가설은, <a href="https://github.com/request/request" target="_blank" rel="external"><code>request</code></a> 패키지에서 전달하는 <code>response</code> stream은<br>flowing mode로 동작한다는 것이다.</p>
<p>즉 <code>s3.upload</code> API에서 stream에서 넘어오는 data를 읽어들이기 전에 이미 <code>response</code> 스트림에 모든 데이터가 전달되었고,<br>따로 이미 해당 스트림은 ‘흐르고 있는’ 모드라 그 데이터가 고스란히 유실된 것.</p>
<p>이 부분을 조금 더 깊게 파보기 위해,<br>Node.js의 꽃 (?) 이라 할 수 있는 Stream에 대해 알아보자.</p>
<h2 id="Node-js의-꽃-Stream"><a href="#Node-js의-꽃-Stream" class="headerlink" title="Node.js의 꽃, Stream"></a>Node.js의 꽃, Stream</h2><p>나는 Node.js에서 가장 매력적이고 핵심적인 부분이 바로 Stream이라 생각한다.</p>
<p>과거 Node.js v0.10 까지는 Stream API에 상당히 많은 변화가 있었다.</p>
<blockquote>
<p>혹시라도 Stream를 아직 잘 모른다면, Node.js의 Contributor이자 npm Inc.의 owner인 <a href="https://github.com/isaacs" target="_blank" rel="external">Isaac Z. Schlueter</a>이<br><a href="http://playnode.io/2012/" target="_blank" rel="external">playnode 2012</a>에서 발표한 <a href="https://dl.dropboxusercontent.com/u/3685/presentations/streams2/streams2-ko.pdf" target="_blank" rel="external">Stream2 슬라이드</a>를 읽어보는 것을 강력하게 추천한다.<br>Node.js 공식 문서의 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="external">Stream 섹션</a>을 참고해보는것도 아주 좋다.</p>
</blockquote>
<p>Node.js에서 Stream은 크게 네가지 종류로 분류된다.<br>Readable Stream, Writable Stream, Duplex Stream, Transform Stream.</p>
<p>여기서 <code>request</code>나 <code>http.get</code>에서 반환하는 <code>response</code> stream은 Readable Stream에 해당하는데,</p>
<p>Readable Stream의 예로는 우리가 흔히 접할 수 있는 것들을 나열하면 다음과 같다: </p>
<p>1) client의 HTTP Request, server의 HTTP Request (<a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage" target="_blank" rel="external">HTTP Class의 IncomingMessage</a>)<br>2) fs.createReadStream 으로 만든 fs readstream<br>3) zlib stream<br>4) crypto stream<br>5) tcp socket<br>6) child process의 stdout, stderr<br>7) process.stdio</p>
<h2 id="Two-Modes"><a href="#Two-Modes" class="headerlink" title="Two Modes"></a>Two Modes</h2><p>Readable Stream에는 <a href="https://nodejs.org/api/stream.html#stream_two_modes" target="_blank" rel="external">두가지 모드</a>가 존재하는데,</p>
<p><code>flowing</code> mode 혹은 <code>paused</code> mode 이다.</p>
<p><code>flowing</code> mode에서는 EventEmitter 인터페이스를 통해 최대한 빠르게 데이터가 전달되고,<br><code>paused</code> mode에서는 명시적으로 <code>stream.read()</code> 메소드를 호출해 chunk를 읽어야 한다.</p>
<p>기본적으로 Readable Stream은 paused mode이지만, 아래 세가지 방법을 통해 flowing mode로 전환할 수 있다.</p>
<ol>
<li><a href="https://nodejs.org/api/stream.html#stream_event_data" target="_blank" rel="external"><code>data</code></a> event handler 등록</li>
<li><a href="https://nodejs.org/api/stream.html#stream_readable_resume" target="_blank" rel="external"><code>stream.resume()</code></a> 메소드 호출</li>
<li><a href="https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options" target="_blank" rel="external"><code>stream.pipe()</code></a>를 통해 Writable Stream으로 데이터 전달</li>
</ol>
<p>그리고 flowing mode의 Readble Stream은 아래 두가지 방법을 통해 다시 paused mode로 전환할 수 있다.</p>
<ol>
<li>pipe 된 대상 writable stream이 없는 상태라면, <a href="https://nodejs.org/api/stream.html#stream_readable_pause" target="_blank" rel="external"><code>stream.pause()</code></a> 메소드 호출</li>
<li>pipe 된 대상 writable stream이 있는 상태라면, <a href="https://nodejs.org/api/stream.html#stream_event_data" target="_blank" rel="external"><code>data</code></a> event handler를 등록 해제하거나 기존에 pipe된 대상 writable stream을 <a href="https://nodejs.org/api/stream.html#stream_readable_unpipe_destination" target="_blank" rel="external"><code>stream.unpipe()</code></a> 메소드를 통해 파이프 해제</li>
</ol>
<h3 id="Three-States"><a href="#Three-States" class="headerlink" title="Three States"></a>Three States</h3><p>두가지 모드와 별개로 Readable Stream은 <a href="https://nodejs.org/api/stream.html#stream_three_states" target="_blank" rel="external">세가지 상태</a>가 존재한다.</p>
<ul>
<li><code>readable._readableState.flowing = null</code></li>
<li><code>readable._readableState.flowing = false</code></li>
<li><code>readable._readableState.flowing = true</code></li>
</ul>
<p><code>readable._readableState.flowing</code> 이 <code>null</code> 인 경우에는 스트림의 데이터를 소비할 어떠한 매커니즘 (<code>data</code> event handler를 등록하거나 <code>pipe</code> method를 통해 다른 writable stream 연결)이 없다는 것이다.<br>이 상태에서는 스트림이 데이터를 만들어내지 않는다.</p>
<p>스트림에 <code>data</code> event listener를 등록하거나, <code>readable.pipe()</code> 메소드를 통해 writable stream을 파이프하거나,<br><code>readable.resume()</code> 메소드를 호출한다면 <code>readable._readableState.flowing</code>이 <code>true</code>으로 변경되고 스트림이 데이터를 생성할때마다 이벤트를 호출하기 시작할 것이다.</p>
<p>마지막으로 <code>readable._readableState.flowing</code> 이 <code>false</code>인  동안에는, 버퍼링을 위해 데이터가 Stream 내부 버퍼에 축적될 것이다.</p>
<p>그렇다면 위 <code>_readableState</code> property를 찍어보면 스트림이 어떤 상태에 있는지 추적해볼 수 있다.<br>다시 코드로 돌아가서, 아래처럼 <code>_readableState</code> property를 찍어보자.</p>
<script src="https://gist.github.com/mooyoul/efe21b18fb513639abe9af5c7c0f5eb7.js"></script>

<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/request-response-stream-state.png" alt="`response` stream의 `flowing` state가 바뀌었다!" title="`response` stream의 `flowing` state가 바뀌었다!">
<p>코드에서 스트림에 손도 안댔는데 <code>response</code> stream의 <code>flowing</code> state가 <code>null</code> 에서 <code>true</code>로 바뀐것을 볼 수 있다!</p>
<p>아까 위에서 언급했지만, Readable Stream의 flowing state가 <code>true</code>인 경우 데이터가 흐르게되어 미리 데이터를 소비할 어떠한 매커니즘을 준비해두지 않는다면 이미 흘러서 나가버린 데이터는 살릴 방법이 없다.</p>
<p>이제 정확히 무엇이 문제인지 알았다. </p>
<p><strong><code>request</code> 패키지에서 전달하는 <code>response</code> stream은 paused &amp; buffered stream이 아니다!</strong></p>
<p>자, 그럼 어떻게 <code>response</code> stream을 paused &amp; buffered stream으로 써멱냐고?<br>솔루션은 간단하다. 이미 stream에 이를 위한 좋은 (?) 구현체가 있다.</p>
<p>Transform Stream의 구현체이기도 한 <a href="https://nodejs.org/api/stream.html#stream_class_stream_passthrough" target="_blank" rel="external"><code>Stream.PassThrough</code></a>가 바로 그것이다.<br>이름만 보고 유추할 수 있겠지만, 그냥 입력 받은 데이터를 다시 출력해주는 스트림이다.<br>다만, 기본적으로 paused state로 동작하고 buffering이 built-in 되어있어서 딱 지금 상황에 쓰기 적절하다.</p>
<p>PassThrough를 쓰도록 처음 코드를 고치면 다음과 같다:</p>
<script src="https://gist.github.com/mooyoul/738d7bfc1e56d4bb6088ff67d4d9f3b6.js"></script>

<p>그리고 테스트를 해보면…. 두근두근…</p>
<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/upload-after-fixed.png" alt="잘 올라간다!" title="잘 올라간다!">
<p>잘 고쳐진 것을 확인할 수 있다!!!!!</p>
<h4 id="왜-Stream을-써야하나요"><a href="#왜-Stream을-써야하나요" class="headerlink" title="왜 Stream을 써야하나요?"></a>왜 Stream을 써야하나요?</h4><p>Download 100MB+ file &amp; upload to s3</p>
<p><strong>using Buffer</strong></p>
<script src="https://gist.github.com/mooyoul/3d4d0e9740cb0195b0483e1be5225c52.js"></script>

<p><strong> vs </strong></p>
<p><strong>using Stream</strong></p>
<script src="https://gist.github.com/mooyoul/738d7bfc1e56d4bb6088ff67d4d9f3b6.js"></script>

<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/buffer-vs-stream.png" alt="Buffer vs Stream" title="Buffer vs Stream">
<h2 id="v-v-STREAM-ALL-THE-THINGS-YAY"><a href="#v-v-STREAM-ALL-THE-THINGS-YAY" class="headerlink" title="v(^_^)v STREAM ALL THE THINGS! (YAY)"></a>v(^_^)v STREAM ALL THE THINGS! (YAY)</h2><img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/stream-all-the-things.jpg" alt="STREAM ALL THE THINGS" title="STREAM ALL THE THINGS">
<h2 id="request와-Streams2-Support"><a href="#request와-Streams2-Support" class="headerlink" title="request와 Streams2 Support"></a>request와 Streams2 Support</h2><p><code>request</code> 패키지의 Contributor인 <a href="https://github.com/mikeal" target="_blank" rel="external">Mikeal Rogers</a>의 <a href="https://github.com/request/request/issues/887#issuecomment-50506277" target="_blank" rel="external">코멘트</a>에 따르면,</p>
<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/mikeal.png" alt="mikeal의 코멘트" title="mikeal의 코멘트">
<p>새로운 스타일의 Stream이 v3 브랜치에서 지원될 것 같아 보인다.</p>
<p>하지만…</p>
<img src="/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/request-v3-branch.png" alt="마지막 업데이트의 상태가..?!" title="마지막 업데이트의 상태가..?!">
<p>현재 v3 브랜치는 마지막 업데이트가 4년 전인 상태로, 사실상 방치중인 상태이다.<br>언젠가 Stream 관련 업데이트가 나올 때 까지는, 이 방법을 쓸 수밖에 없을 것 같다 ㅠㅠ</p>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2017/02/18/Fixing-broken-stream-on-nodejs-request-package/request.png&quot; alt=&quot;request&quot; title=&quot;request&quot;&gt;
&lt;h1 id=&quot;Node-js-request-패키지
    
    </summary>
    
      <category term="nodejs" scheme="https://mooyoul.github.io/categories/nodejs/"/>
    
    
      <category term="request" scheme="https://mooyoul.github.io/tags/request/"/>
    
      <category term="nodejs" scheme="https://mooyoul.github.io/tags/nodejs/"/>
    
      <category term="stream" scheme="https://mooyoul.github.io/tags/stream/"/>
    
      <category term="aws" scheme="https://mooyoul.github.io/tags/aws/"/>
    
      <category term="s3" scheme="https://mooyoul.github.io/tags/s3/"/>
    
  </entry>
  
  <entry>
    <title>AWS Lambda에서의 Timezone 설정</title>
    <link href="https://mooyoul.github.io/2017/02/16/Setting-Timezone-on-AWS-Lambda/"/>
    <id>https://mooyoul.github.io/2017/02/16/Setting-Timezone-on-AWS-Lambda/</id>
    <published>2017-02-15T19:31:39.000Z</published>
    <updated>2017-02-17T22:13:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AWS-Lambda에서의-Timezone-설정"><a href="#AWS-Lambda에서의-Timezone-설정" class="headerlink" title="AWS Lambda에서의 Timezone 설정"></a>AWS Lambda에서의 Timezone 설정</h1><blockquote>
<p>TL;DR <strong><code>TZ</code> 환경 변수(Environment Variable) 통해서 Timezone을 설정할 수 있어요</strong></p>
</blockquote>
<p>오늘 AWS Lambda에 크롤러를 만들어 올렸는데 컨텐츠를 제대로 가져오지 못하는 일이 생겼다.<br>분명 로컬에서는 잘 돌아가는데, Lambda로 배포하고 돌려보면 컨텐츠를 제대로 가져오지 못했다.</p>
<img src="/2017/02/16/Setting-Timezone-on-AWS-Lambda/lambda-before-set-tz.png" alt="Timezone 설정하기 전 UTC로 포매팅되는 모습" title="Timezone 설정하기 전 UTC로 포매팅되는 모습">
<p>원인을 찾아보니, 크롤러에서 요청을 날릴때 query string을 만드는 과정에 날짜를 포매팅하는게 문제가 있었다.<br>query string을 만들때 <a href="https://momentjs.com/" target="_blank" rel="external">moment.js</a>로 날짜를 <code>YYYY-MM-DD</code> 형식으로 포매팅하고 있었는데,<br>로컬 머신의 경우 GMT+9인 한국 타임존이 이미 설정되어 있는 상황이었고, AWS Lambda가 돌아가는 컨테이너는 UTC라 타임존 차이로 결과가 달라진 것이었다.</p>
<p>예~전에 RDS에서도 기본 Timezone이 UTC로 설정되어 있어서 동일한 이슈를 이미 겪어봤기에 바로 타임존 문제임을 알아챌 수 있었다.</p>
<p>그런데 RDS의 경우 Parameter group에서 Timezone 설정만 변경해주면 되는데,<br>AWS Lambda의 경우 코드만 올리고 땡이라 <strong>그런거 없다.</strong></p>
<p>그리고 일반적으로 리눅스 박스에서 Timezone을 변경하려면 <code>/etc/localtime</code> 혹은  <code>/etc/timezone</code>을 수정하는 방법을 썼는데,<br>AWS Lambda는 코드만 돌아가는 서비스라 그걸 변경하기도 불가능하다. 애초에 Root access가 막혀있어서 파일을 수정할 수 없다.</p>
<img src="/2017/02/16/Setting-Timezone-on-AWS-Lambda/lambda-after-set-tz.png" alt="Timezone을 Asia/Seoul로 설정한 후 포매팅되는 모습" title="Timezone을 Asia/Seoul로 설정한 후 포매팅되는 모습">
<p>정말 다행히 Lambda에서 환경 변수를 지원해서, <code>TZ</code> 환경 변수를 <code>Asia/Seoul</code>로 설정해봤더니.<br>너무 잘 된다. POSIX 짱짱맨!!!!</p>
<blockquote>
<p>Node.js 런타임 내에서 <code>TZ</code> 환경변수를 설정할 경우 (e.g. <code>process.env.TZ = &#39;Asia/Seoul&#39;;</code>),<br>어떠한 Date 함수를 호출하기 전에 반드시 먼저 <code>TZ</code> 환경변수를 설정해야한다.<br>그렇지 않는다면 Timezone 설정이 적용되지 않는다.</p>
</blockquote>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html" target="_blank" rel="external">Specifying the Time Zone with TZ - GNU libc</a></li>
<li><a href="https://groups.google.com/forum/#!topic/nodejs/s1gCV44KYrQ" target="_blank" rel="external">Set timezone within node? - Node.js Google Groups (무려 2010년에 작성된 쓰레드이다.)</a></li>
<li><a href="https://github.com/nodejs/node-v0.x-archive/issues/3286" target="_blank" rel="external">changing process.env.TZ at runtime produces non-deterministic behavior - Node.js v0.x archive</a></li>
<li><a href="http://www.iana.org/time-zones" target="_blank" rel="external">Timezone Database - IANA</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AWS-Lambda에서의-Timezone-설정&quot;&gt;&lt;a href=&quot;#AWS-Lambda에서의-Timezone-설정&quot; class=&quot;headerlink&quot; title=&quot;AWS Lambda에서의 Timezone 설정&quot;&gt;&lt;/a&gt;AWS Lambda에
    
    </summary>
    
      <category term="serverless" scheme="https://mooyoul.github.io/categories/serverless/"/>
    
    
      <category term="aws" scheme="https://mooyoul.github.io/tags/aws/"/>
    
      <category term="timezone" scheme="https://mooyoul.github.io/tags/timezone/"/>
    
      <category term="serverless" scheme="https://mooyoul.github.io/tags/serverless/"/>
    
      <category term="lambda" scheme="https://mooyoul.github.io/tags/lambda/"/>
    
      <category term="heroku" scheme="https://mooyoul.github.io/tags/heroku/"/>
    
      <category term="cloudfunctions" scheme="https://mooyoul.github.io/tags/cloudfunctions/"/>
    
      <category term="gcf" scheme="https://mooyoul.github.io/tags/gcf/"/>
    
  </entry>
  
  <entry>
    <title>Terraform 101</title>
    <link href="https://mooyoul.github.io/2016/12/19/Terraform-101/"/>
    <id>https://mooyoul.github.io/2016/12/19/Terraform-101/</id>
    <published>2016-12-18T18:24:42.000Z</published>
    <updated>2017-02-17T22:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<img src="/2016/12/19/Terraform-101/terraform.png" alt="Terraform" title="Terraform">
<h1 id="Terraform"><a href="#Terraform" class="headerlink" title="Terraform"></a>Terraform</h1><p>Terraform은 <strong>Infrastructure as code</strong>를 모토로 하는 <a href="https://www.hashicorp.com/" target="_blank" rel="external">Hashicorp</a>의 오픈소스 도구입니다.</p>
<p>인프라 구성을 코드를 통해 효과적이고 안전하게 만들고, 변경하고, 버저닝할 수 있습니다.</p>
<p>SVN, Git과 같은 버전 제어 시스템과 함께 사용한다면 다른 사람과 함께 구성을 변경할 수 있으며,<br>변경 이력을 투명하게 살펴볼 수 있고, 코드로 작성되므로 자동화가 가능합니다.</p>
<h2 id="코드로-표현된-인프라"><a href="#코드로-표현된-인프라" class="headerlink" title="코드로 표현된 인프라"></a>코드로 표현된 인프라</h2><p>다음은 Terraform 공식 홈페이지에서 소개하고 있는 한 예제입니다.<br>예제를 살펴보면 코드로 인프라를 표현한다는 것이 무엇을 의미하는지 바로 알 수 있습니다.</p>
<script src="https://gist.github.com/mooyoul/5f0221b2b5cf637834e4685f71f24b1f.js"></script>

<p>위 Terraform 코드는 인프라 내에 두개의 리소스를 정의합니다.</p>
<p>하나는 DigitalOcean의 Droplet을 정의하는 리소스이고,<br>다른 하나는 DNSimple의 레코드를 정의하는 리소스입니다.</p>
<p>여기서 DNSimple의 레코드를 정의한 리소스를 보면 흥미로운 부분이 있는데,<br><strong>위 DigitalOcean Droplet의 Public IP를 참조하고 있다</strong>는 것입니다.</p>
<p>즉, 다른 리소스의 정보를 참조하여 정말 유연하게 인프라를 구성할 수 있죠!</p>
<h2 id="비슷한-소프트웨어와-무엇이-다른가"><a href="#비슷한-소프트웨어와-무엇이-다른가" class="headerlink" title="비슷한 소프트웨어와 무엇이 다른가?"></a>비슷한 소프트웨어와 무엇이 다른가?</h2><p>AWS의 CloudFormation, Heat은 코드로 인프라를 구성한다는 점에서 Terraform과 비슷하지만,<br>다음과 같은 차이가 있습니다.</p>
<ol>
<li>Terraform은 다양한 Vendor를 지원하므로, 유연한 인프라 구성이 가능하다.<ul>
<li>e.g.) DNS 서비스는 DNSimple을 사용하고, CDN은 Akamai로 구성</li>
</ul>
</li>
<li>오픈소스 생태계<ul>
<li>공통된 Terraform 설정은 모듈로 패키징되어 재사용할 수 있다.</li>
</ul>
</li>
<li>적용 전 변경사항 미리보기 가능 (Plan)<ul>
<li>Terraform은 계획과 적용 단계가 분리되어 있어 변경사항 적용 전 무엇이 변경되는지 검토가 가능</li>
</ul>
</li>
<li>리소스간 의존성을 그래프로 확인할 수 있음 (Graph)<ul>
<li>dot-formatted 이므로 <a href="http://www.graphviz.org/" target="_blank" rel="external">Graphviz</a>로 의존성 그래프를 시각화 할수도 있음</li>
</ul>
</li>
</ol>
<p>Terraform은 실행 계획이 캡쳐되면, 실행 단계는 캡쳐된 실행 계획에서 필요로 하는 부분만 반영하도록 제한합니다.</p>
<p>다른 도구들은 계획과 실행 단계가 분리되어 있지 않고 합쳐져있어 오퍼레이터들이 인프라 구성 변경으로 무엇이 변경되는지 추론하도록 강요받지만,<br>Terraform은 변경사항 적용 이전에 무슨 일이 벌어지는지 정확하게 알 수 있게 제공함으로써, 오퍼레이터들이 변경사항을 적용하는 것을 신뢰할 수 있게 합니다.</p>
<h2 id="Terraform-설치"><a href="#Terraform-설치" class="headerlink" title="Terraform 설치"></a>Terraform 설치</h2><p>Terraform은 단일 실행파일로 배포되고 있으며, 이 덕분에 설치가 아주 간단합니다.</p>
<p><a href="https://www.terraform.io/downloads.html" target="_blank" rel="external">공식 홈페이지의 Downloads 페이지</a>에서 Terraform을 얻을 수 있습니다.</p>
<p>이 글을 작성하는 시점에서는 0.8.1 버전이 최신 버전이고, macOS 기준 Terraform을 설치하는 방법은 다음과 같습니다:</p>
<blockquote>
<p>$ # echo $PATH 를 통해 실행 경로를 미리 확인하세요.<br>$ # 저는 /usr/local/bin 을 즐겨쓰기에 해당 경로를 기준으로 했습니다.<br>$ wget <a href="https://releases.hashicorp.com/terraform/0.8.1/terraform_0.8.1_darwin_amd64.zip" target="_blank" rel="external">https://releases.hashicorp.com/terraform/0.8.1/terraform_0.8.1_darwin_amd64.zip</a><br>$ unzip terraform_0.8.1_darwin_amd64.zip<br>$ cp terraform /usr/local/bin/ # root 권한이 필요한 경우 sudo를 사용해야 할 수 있습니다.</p>
</blockquote>
<p>참 쉽죠?!</p>
<p>설치를 확인하려면 터미널에서 terraform을 그냥 실행해보면 됩니다.</p>
<blockquote>
<p>$ terraform</p>
</blockquote>
<img src="/2016/12/19/Terraform-101/hello-terraform.png" alt="Hello, Terraform!" title="Hello, Terraform!">
<h2 id="Terraform으로-인프라-만들기"><a href="#Terraform으로-인프라-만들기" class="headerlink" title="Terraform으로 인프라 만들기"></a>Terraform으로 인프라 만들기</h2><p>Terraform을 설치했으니, Terraform으로 새로운 인프라를 구성해보겠습니다.<br>이 섹션에서는 몇가지 AWS 서비스들을 Terraform으로 구성하는 방법을 소개하므로,<br>미리 IAM 에서 Access Key를 발급받아 두시길 바랍니다!</p>
<h4 id="첫-Terraform-설정-파일-만들기"><a href="#첫-Terraform-설정-파일-만들기" class="headerlink" title="첫 Terraform 설정 파일 만들기"></a>첫 Terraform 설정 파일 만들기</h4><p>우리는 이번 섹션에서 새로운 EC2 인스턴스를 만들기 위해 새로운 Terraform 설정 파일을 만들어보겠습니다.</p>
<p>Terraform 설정 파일은 <a href="https://github.com/hashicorp/hcl" target="_blank" rel="external">Hashicorp Configuration Language (HCL)</a> 이라는 문법을 사용하고, <code>.tf</code> 확장자를 사용합니다.<br>HCL은 JSON과 완벽히 호환되고, Terraform 설정 파일은 JSON으로도 작성하여 사용할 수 있습니다 (이 경우에는 <code>.tf.json</code> 을 사용합니다.)</p>
<p>Terraform 설정 파일에 대한 자세한 내용은 <a href="https://www.terraform.io/docs/configuration/" target="_blank" rel="external">이곳</a>을 참고하시고,<br>일단 새로운 Terraform 설정 파일을 만들어보겠습니다. </p>
<p>먼저, <code>terraform-101</code> 이라는 디렉토리를 새로 만든 후, 해당 디렉토리에 아래 내용을 <code>example.tf</code>으로 저장하세요.<br>(기본적으로 Terraform은 working directory의 모든 <code>.tf</code> 파일을 불러오기 때문에, 만일을 대비해 새로운 디렉터리를 만드는 것입니다.)</p>
<p>지금은 AWS의 Access Key와 Secret Key를 직접 기입했지만,<br>나중에는 변수에서 두 값을 추출해서 사용하는 방법을 알아볼 것이니 하드코딩된 값을 너무 신경쓰진 마세요!</p>
<script src="https://gist.github.com/mooyoul/d707c4cad5354d5c8e5bf9b79dc6c12d.js"></script>

<p>위 설정은 바로 적용해 볼 수 있는 (완전한) 예제입니다.</p>
<p>기본적인 구조를 설명하면 다음과 같습니다:</p>
<p><code>provider</code> block은 알려진 Provider를 구성하기 위해 사용됩니다.<br>위 예제에서는 EC2 리소스를 정의하기 위해 <code>&quot;aws&quot;</code>를 사용했습니다.<br>Provider는 리소스를 생성하고 관리하는 책임 (역할)을 가집니다.<br>여러 서비스를 관리하기 위해 복수의 Provider를 정의할 수도 있습니다 (e.g. Akamai + AWS + DNSimple)</p>
<p><code>resource</code> block은 인프라 내에 존재하는 리소스를 정의하기 위해 사용됩니다.<br>하나의 리소스는 EC2 인스턴스나 Heroku 애플리케이션과 같은 물리적인 컴포넌트를 의미합니다.</p>
<p>Resource block은 block이 시작되기 전 두개의 문자열을 가지고 있습니다.<br>바로 <strong>리소스의 타입</strong>과 <strong>리소스의 이름</strong>입니다.<br>위 예제를 기준으로 하면 <code>aws_instance</code>가 리소스의 타입이고, <code>example</code>이 리소스의 이름이 됩니다.</p>
<p>Terraform에서는 리소스의 타입에 붙은 접두사(Prefix)를 통해 Provider에 매핑합니다.<br><code>aws_instance</code>의 경우, 접두사는 <code>aws</code>이고, 이는 <code>aws</code> provider에 의해 관리되는 리소스임을 의미합니다.</p>
<p>Resource block 안에는 해당 리소스와 관련한 속성들이 들어갑니다.<br>위 예제의 경우 Ubuntu 16.04 LTS AMI를 사용하고, <code>t2.micro</code> 인스턴스를 정의했습니다.</p>
<h4 id="실행-계획-Execution-Plan"><a href="#실행-계획-Execution-Plan" class="headerlink" title="실행 계획 (Execution Plan)"></a>실행 계획 (Execution Plan)</h4><p>이제 Terraform이 위 환경을 적용할 때 무엇을 할지 살펴보기로 합니다.</p>
<p>위 <code>example.tf</code> 가 있는 디렉토리에서 <code>terraform plan</code> 명령을 실행해보세요.</p>
<p>아래와 비슷한 내용이 출력될 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-plan.png" alt="terraform plan" title="terraform plan">
<p><code>terraform plan</code> 명령은 현재 환경에서 Terraform이 어떠한 변경사항을 만들어내는지 보여줍니다.<br>출력 내용은 Git과 비슷한 형식으로 어떤 항목들이 변경되는지 알려줍니다.</p>
<p>위의 경우 <code>aws_instance.example</code> 리소스가 새롭게 생성될 것이고,<br>총 1개의 생성 / 0개의 수정 / 0개의 삭제가 발생한다는 것을 알 수 있죠.</p>
<p><code>&lt;computed&gt;</code> 라고 표기된 값은 리소스가 생성되기 전까지는 알 수 없습니다.<br>당연하겠지만 (?) EC2 인스턴스를 생성하기 전에 미리 Private IP를 알아낼 수는 없으니까요.<br>그렇지만, Terraform에서는 인프라를 구성할 때 다른 리소스에서 <code>&lt;computed&gt;</code>로 표기된 해당 속성의 값을 참조할 수 있습니다. (이따 자세히 알아보겠습니다!)</p>
<h4 id="적용-Apply"><a href="#적용-Apply" class="headerlink" title="적용 (Apply)"></a>적용 (Apply)</h4><p>위 <code>terraform plan</code> 명령으로 확인한 변경사항이 적절하다고 판단되면, 이제 실제로 리소스를 만들 시간입니다. (위 예제에서 EC2 인스턴스를 만드니까요)</p>
<p>적용은 <code>terraform apply</code> 명령을 사용하면 됩니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-apply.png" alt="terraform apply" title="terraform apply">
<p>와우! 인스턴스를 새롭게 만들고, 해당 인스턴스가 준비될 때 까지 기다리는걸 확인할 수 있습니다!</p>
<p>EC2 대시보드에서 확인해보니, 정말 잘 만들어졌네요.</p>
<img src="/2016/12/19/Terraform-101/ec2-dashboard-after-apply.png" alt="생성된 인스턴스를 EC2 Dashboard에서도 확인할 수 있습니다." title="생성된 인스턴스를 EC2 Dashboard에서도 확인할 수 있습니다.">
<p>또한 기본적으로 Terraform은 몇몇 상태 정보를 <code>terraform.tfstate</code> 파일에 저장합니다.</p>
<p>이 상태 파일은 아주 중요한데, Terraform이 무엇을 관리하고 있는지 알 수 있도록 여러 리소스의 메타데이터를 실제 리소스 ID로 매핑한 정보를 담고 있기 때문입니다.<br>그리고 이 상태 파일은 Terraform을 사용하려는 유저가 있다면 (e.g. 다른 팀원), 반드시 환경설정 파일과 함께 저장되어야하고 함께 배포되어야만 합니다.<br>다만 이 상태 파일에는 잠재적인 비밀 정보를 포함할 수 있으므로, Terraform에서는 원격에서 상태를 저장할 수 있도록 설정을 구성하는 것을 권장하고 있습니다.</p>
<p>원격 상태 관리에 대해서는 다음 링크에서 자세히 살펴보시기 바랍니다:<br><a href="https://www.terraform.io/docs/state/remote/index.html" target="_blank" rel="external">https://www.terraform.io/docs/state/remote/index.html</a></p>
<p>현재 인프라 구성 상태를 확인하고 싶은 경우, <code>terraform show</code> 명령을 사용하면 됩니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-show.png" alt="terraform show" title="terraform show">
<p>아까 Plan / Apply 명령을 내렸을 때와는 다르게, 생성한 리소스에 대해 자세한 정보를 얻을 수 있는 것을 확인하실 수 있습니다.</p>
<h2 id="Terraform-으로-인프라-변경하기"><a href="#Terraform-으로-인프라-변경하기" class="headerlink" title="Terraform 으로 인프라 변경하기"></a>Terraform 으로 인프라 변경하기</h2><p>우리는 방금 전 Terraform으로 하나의 EC2 인스턴스를 생성하는 첫 인프라를 만들었습니다.<br>이번에는 Terraform으로 위 인스턴스를 변경해보도록 하겠습니다.<br>Terraform이 어떻게 변경사항을 다루는지 보세요!</p>
<p>Terraform으로 인프라를 변경할 때, Terraform은 변경될 상태에 필요한 부분만 변경하는 실행 계획을 만듭니다.</p>
<h4 id="설정-변경"><a href="#설정-변경" class="headerlink" title="설정 변경"></a>설정 변경</h4><p>방금 만든 EC2 인스턴스는 Ubuntu 16.04 LTS AMI를 사용하고 있는데,<br>이를 Amazon Linux AMI로 변경해보도록 하겠습니다.</p>
<p>설정을 변경하는 방법은 아주 간단합니다.<br>우리는 AMI 이미지를 교체하려고 하므로, resource 블럭 내의 <code>ami</code> 속성의 값을 <code>ami-983ce8f6</code> 으로 변경하기만 하면 됩니다.</p>
<script src="https://gist.github.com/mooyoul/04b2d34fe1c5e873f7bda89facc9bd89.js"></script>

<p>요렇게요.</p>
<p>변경사항을 반영하는것은 이전 단계에서 배웠습니다.<br><code>terraform plan</code> 으로 실행 계획을 체크하고, 문제가 없다면 <code>terraform apply</code> 으로 반영하면 됩니다.</p>
<h4 id="설정-변경-후의-실행-계획-Execution-Plan"><a href="#설정-변경-후의-실행-계획-Execution-Plan" class="headerlink" title="설정 변경 후의 실행 계획 (Execution Plan)"></a>설정 변경 후의 실행 계획 (Execution Plan)</h4><p>설정을 변경하고 나서 <code>terraform plan</code> 명령을 실행하면 다음과 같은 화면이 나올 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-after-modification.png" alt="설정 변경 후 terraform plan" title="설정 변경 후 terraform plan">
<p>변경사항 앞에 붙은 <code>-/+</code> 접두사는 Terraform이 해당 리소스를 제거하고 재생성한다는 의미입니다.<br>반대로, 변경하는 일부 속성이 리소스의 제거 없이 즉시 업데이트가 가능한 경우 Terraform은 <code>~</code> 접두사로 변경사항을 표시하게 됩니다.<br>(<code>~</code> 접두사가 붙은 것은 차차 확인하기로 하고, 일단 넘어갑시다!)</p>
<p>EC2 인스턴스의 AMI를 변경하는 것은 새 인스턴스를 생성하는 것을 요구하기 때문에, 기존 리소스를 제거하고 새롭게 생성해야하죠. </p>
<p>Terraform은 우리를 위해 이러한 디테일도 잘 다루어줍니다. (세심해라…)</p>
<p>그래서 실행 계획 (Execution Plan) 에서 Terraform이 무엇을 할지 명확하게 알 수 있죠.</p>
<p>덧붙여서, 실행 계획의 결과를 보면 AMI에 대한 변경사항이 리소스를 삭제하고 재생성하도록 요구했다는 것을 알아챌 수 있습니다.<br>이 정보를 적절히 사용한다면, 특정 시점에 리소스를 제거하거나 생성하는 업데이트를 피하기 위해 변경사항을 조절할 수도 있습니다.<br>(e.g. 일단 리소스 재생성 없이 즉시 적용할 수 있는 변경사항부터 적용하고, 리소스 재생성을 요구하는 변경사항은 나중에 적용하기)</p>
<h4 id="설정-변경-후-적용-Apply"><a href="#설정-변경-후-적용-Apply" class="headerlink" title="설정 변경 후 적용 (Apply)"></a>설정 변경 후 적용 (Apply)</h4><p>이전 실행 계획 섹션에서 우리는 무엇이 변경될 지 알아냈습니다. 그럼 이번엔 적용해보죠.</p>
<p>이전과 동일하게 <code>terraform apply</code> 를 통해 변경사항을 적용하면 됩니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-apply-after-modification.png" alt="설정 변경 후 terraform apply" title="설정 변경 후 terraform apply">
<p>실행 계획에서 예측한 대로, 기존 인스턴스를 제거하고, 새 인스턴스를 생성하는 것을 확인할 수 있습니다.</p>
<img src="/2016/12/19/Terraform-101/ec2-dashboard-after-modification-apply.png" alt="설정 변경 후 EC2 Dashboard" title="설정 변경 후 EC2 Dashboard">
<p>EC2 대시보드에서 확인해보면, 인스턴스를 제거하고 새롭게 생성한 것을 확인할 수 있습니다.<br>Amazon Linux AMI로 바뀐 것이 보입니다!</p>
<p><code>terraform show</code>를 통해 새로운 인스턴스의 속성들을 확인할 수도 있습니다.</p>
<p>여러분들은 Terraform과 함께 인프라를 변경하는 것이 얼마나 쉬운지 보았습니다.<br>다음 섹션에서는 우리가 만든 인프라를 통째로 제거해 보겠습니다.</p>
<h2 id="Terraform으로-인프라-제거하기"><a href="#Terraform으로-인프라-제거하기" class="headerlink" title="Terraform으로 인프라 제거하기"></a>Terraform으로 인프라 제거하기</h2><p>우리는 Terraform으로 인프라를 어떻게 생성하고 변경하는지 알아봤습니다.<br>이번 섹션에서는 여러개의 리소스들을 생성하고 의존성을 표시하는지 알아보기 전에,<br>Terraform으로 관리하는 인프라를 <strong>완전히</strong> 제거하는 방법을 알아보도록 하겠습니다.<br>그러니까, <strong>인프라 내에 포함된 모든 리소스들을 제거하는 방법</strong>이겠죠.</p>
<p>여러분들의 인프라를 제거한다는 것은 프로덕션 환경에서 아주 드문 일입니다만,<br>여러분들이 만약 Terraform을 개발, 테스트, QA 환경과 같은 (자주 바뀌는) 인프라를 구성하기 위해 사용한다면,<br>(모든 리소스를 삭제하기 위해) 인프라를 제거하는 기능을 유용하게 사용할 수도 있을 것입니다.</p>
<h4 id="인프라-제거시-실행-계획-Execution-Plan"><a href="#인프라-제거시-실행-계획-Execution-Plan" class="headerlink" title="인프라 제거시 실행 계획 (Execution Plan)"></a>인프라 제거시 실행 계획 (Execution Plan)</h4><p>우리의 인프라를 제거하기 전에, 우리는 <code>terraform plan -destroy</code> 명령을 통해 어떤 리소스들이 제거되는지 미리 확인할 수 있습니다.<br><code>-destroy</code> 플래그를 사용하는 경우, 우리는 Terraform에게 인프라를 제거하는 실행 계획을 묻게 됩니다.<br>인프라를 제거한다는 것은, Terraform이 관리하는 모든 리소스를 제거한다는 것을 의미합니다.</p>
<p>여러분들은 이 명령의 결과로 Terraform이 어떤 어떤 리소스들을 관리하고 있고 제거하는지 검증할 수 있습니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-destroy.png" alt="terraform plan -destroy" title="terraform plan -destroy">
<p>현재는 구성해둔 리소스가 AWS의 EC2 인스턴스 하나이므로 해당 인스턴스 하나만 표시가 됩니다.</p>
<h4 id="제거"><a href="#제거" class="headerlink" title="제거"></a>제거</h4><p>변경사항 적용과 달리 인프라를 제거하는 작업은 <code>apply</code> 명령이 아닌 <code>destroy</code> 명령을 사용합니다.<br><code>terraform destroy</code> 명령을 통해 한번 인프라를 제거해보도록 하겠습니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-destroy-confirmation.png" alt="terraform destroy confirmation" title="terraform destroy confirmation">
<p>당연하겠지만, 정말 인프라를 제거할 것인지 확인하는 절차가 있습니다.<br>여기서 <code>Ctrl + C</code>로 인터럽트를 하거나, <code>yes</code> 이외의 응답을 하면 인프라 제거를 취소할 수 있습니다.<br>Terraform은 안전을 위한 매커니즘으로 오직 <code>yes</code> 만 올바른 응답으로 취급합니다.</p>
<p>지금은 연습이기 때문에 마음 편하게 <code>yes</code>를 입력할 수 있지만,<br><strong>인프라를 제거하는 작업은 취소할 수 없으므로 항상 주의</strong>해야합니다.</p>
<p><code>yes</code> 를 입력하고 <code>Enter</code> 키를 눌러 응답하면 실제로 인프라가 제거되는 것을 확인할 수 있습니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-destroy.png" alt="terraform destroy" title="terraform destroy">
<p>덧붙여서, <code>terraform apply</code> 명령처럼, Terraform은 어떤 순서로 항목을 제거할지 결정할정도로 똑똑합니다.<br>이번 예제에서는 오직 한 리소스만 존재하기 때문에 순서를 지정해 리소스를 제거할 필요는 없지만,<br>여러 리소스가 존재하는 복잡한 케이스의 경우라면 Terraform은 올바른 순서로 리소스를 제거 할 것입니다.</p>
<p>여러분들은 로컬 머신에서 Terraform을 통해 인프라를 만들고, 수정하고, 제거하는 방법을 배웠습니다.</p>
<p>Terraform의 강력함은 간편한 관리도 있지만, 리소스간 의존성을 둘 수 있는 점 또한 큰 장점입니다.</p>
<p>다음 섹션에서는 Terraform에서 리소스 간 의존성을 정의하는 방법을 알아보도록 하겠습니다.</p>
<h2 id="리소스-의존성-Resource-Dependency"><a href="#리소스-의존성-Resource-Dependency" class="headerlink" title="리소스 의존성 (Resource Dependency)"></a>리소스 의존성 (Resource Dependency)</h2><p>이번 섹션에서 우리는 리소스 의존성을 알아볼 것입니다.<br>여러분들은 여러복수의 리소스를 정의하는것을 보실 수 있을 뿐만 아니라,<br>다른 리소스의 정보를 참조하도록 리소스 파라미터를 사용하는 것을 확인할 수 있습니다.</p>
<p>지금까지는 우리는 오직 한 리소스만 포함하는 인프라를 구성했었습니다.<br>하지만 실제 인프라는 다양한 리소스와 여러 리소스 종류를 가지고 있습니다.<br>Terraform 설정은 여러 리소스들과 리소스 종류를 포함할 수 있고, 이러한 리소스 종류들은 여러 Provider를 통해 더 늘릴 수 있습니다.</p>
<p>이번 섹션에서는 우리는 여러 리소스를 다루는 예제와 함께,<br>어떻게 리소스가 특정 리소스의 속성을 참조해 해당 리소스를 구성할 수 있는지 알아보겠습니다.</p>
<h4 id="Elastic-IP-할당하기"><a href="#Elastic-IP-할당하기" class="headerlink" title="Elastic IP 할당하기"></a>Elastic IP 할당하기</h4><p>기존에 관리하던 EC2 인스턴스에 Elastic IP를 할당해 기존 설정을 개선해보도록 하겠습니다.<br>여러분들의 기존 <code>example.tf</code> 환경설정 파일에 다음 항목을 추가하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">resource &quot;aws_eip&quot; &quot;ip&quot; &#123;</div><div class="line">    instance = &quot;$&#123;aws_instance.example.id&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/171468de36b2d462e1a4e955eb0cc690.js"></script>

<p>위 스니펫에서 정의한 리소스는 <code>aws_eip</code> 리소스 타입을 정의하는 것만 제외하면 이전에 EC2 인스턴스 리소스를 추가할 때와 많이 비슷할 것입니다.</p>
<p><code>aws_eip</code> 리소스 종류는 Elastic IP를 할당하고, 해당 Elastic IP를 EC2 인스턴스에 연동합니다.<br><code>aws_eip</code> 리소스 종류는 정의된 단 하나의 파라미터인 <code>instance</code> 속성이 있는데, 해당 속성에 지정된 인스턴스에 해당 Elastic IP를 연동하게 됩니다.<br>이번에 해당 <code>instance</code> 속성에 설정하는 값은 일종의 템플릿 표기법(interpolation)을 이용하여,<br>우리가 이전에 관리하던 EC2 인스턴스의 속성 값을 참조할 수 있도록 합니다.</p>
<p>템플릿 표기법(interpolation)은 간단합니다.<br>위 예제에서는 <code>aws_instance.example</code> 리소스의 <code>id</code> 속성을 참조하라는 의미입니다.</p>
<h4 id="계획과-실행-Plan-amp-Execute"><a href="#계획과-실행-Plan-amp-Execute" class="headerlink" title="계획과 실행 (Plan &amp; Execute)"></a>계획과 실행 (Plan &amp; Execute)</h4><p>실행 플랜을 보기 위해 <code>terraform plan</code> 명령을 실행해보세요.<br>아마 다음과 같은 출력이 나올 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-with-dependency.png" alt="terraform plan (with resource dependency)" title="terraform plan (with resource dependency)">
<p>테라폼은 EC2 인스턴스 하나와 Elastic IP 하나, 총 두개의 리소스를 만들 것입니다.<br>여기서 <code>aws_eip</code> 의 <code>instance</code> 속성 값이 아직 템플릿 표기법(interpolation) 으로 표시되는데,<br>이는 해당 변수 (variable)는 <code>aws_instance</code> 가 생성될 때 까지는 알 수 없기 때문입니다.</p>
<p>이 이유로, 해당 값은 적용 시점 (apply-time)에서 되기 떄문에 <code>terraform apply</code> 명령의 결과로만 확인할 수 있습니다.</p>
<p>그렇다면, 얼른 확인해보도록 하죠.</p>
<p><code>terraform apply</code> 명령을 실행해 현재 구성을 적용합니다.</p>
<p>이번에는 다음과 같은 결과가 나올 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-apply-with-dependency.png" alt="terraform apply (with resource dependency)" title="terraform apply (with resource dependency)">
<p>여기서 Terraform이 실제로 동작하는 것을 볼 수 있는데,<br>Terraform이 Elastic IP를 할당받기 이전에 (Elastic IP 리소스를 생성하기 이전에) EC2 인스턴스를 먼저 생성하는것을 볼 수 있습니다.</p>
<p>이전에 Elastic IP의 <code>instance</code> 속성의 값을 EC2 인스턴스의 ID를 참조하는 템플릿 표기법(interpolation)으로 기입했기 때문에,<br>Terraform은 의존성을 추론할 수 있고, 인스턴스를 먼저 만들어야 함을 알 수 있습니다.</p>
<h4 id="암시적인-의존성과-명시적인-의존성-Implicit-and-Explicit-Dependencies"><a href="#암시적인-의존성과-명시적인-의존성-Implicit-and-Explicit-Dependencies" class="headerlink" title="암시적인 의존성과 명시적인 의존성 (Implicit and Explicit Dependencies)"></a>암시적인 의존성과 명시적인 의존성 (Implicit and Explicit Dependencies)</h4><p>Terraform에서 대부분의 의존성들은 암시적입니다. Terraform은 리소스간의 속성 참조를 기반으로 의존성을 추론하기 때문입니다.</p>
<p>Terraform은 의존성 정보를 통해 리소스들의 관계를 그래프로 그리고,<br>어떤 순서로 리소스들을 생성할 지 결정할 뿐만 아니라, 어떤 리소스들이 병렬로 동시에 생성될 수 있을지 추론합니다.<br>위의 예제에서는, Elastic IP가 EC2 인스턴스에 의존적이므로 그 두개의 리소스는 병렬로 (동시에) 생성될 수 없었습니다.</p>
<p>암시적인 의존성은 잘 동작하고 대개 여러분들이 원하는 것이긴 하지만,<br>여러분들은 모든 리소스에서 사용 가능한 <code>depends_on</code> 속성을 통해 명시적인 의존성을 정의할 수 있습니다.</p>
<p>이번에는 이전 예제와 동일하게 동작하고 불필요하긴 속성이긴 하지만<br><code>aws_eip</code> 리소스에 <code>depends_on</code> 속성을 정의해 명시적인 의존성을 정의해보도록 하겠습니다.</p>
<p>아래와 같이 <code>depends_on</code> 속성을 기입하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">resource &quot;aws_eip&quot; &quot;ip&quot; &#123;</div><div class="line">    instance = &quot;$&#123;aws_instance.example.id&#125;&quot;</div><div class="line">    depends_on = [&quot;aws_instance.example&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/8b898db453731fdf86dc28895c28e4a0.js"></script>

<p>만약 여러분이 Terraform이 생성하는 의존성 구조 (dependency chain)에 대해 확신하지 못했다면,<br>이번 기회에 <code>terraform graph</code> 명령을 사용해 그래프를 확인해보세요.<br><code>terraform graph</code> 명령의 출력 결과는 <a href="http://www.graphviz.org/" target="_blank" rel="external">Graphviz</a>로도 확인할 수 있는 dot 형식 (dot-formatted) 입니다.</p>
<p><code>terraform graph</code> 명령을 실행하면 다음과 같은 결과가 나올 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-graph.png" alt="terraform graph" title="terraform graph">
<p>위 이미지에서 하이라이트한 라인을 보면, <code>aws_eip.ip</code> 리소스가 <code>aws_instance.example</code> 리소스에 의존성을 가지고 있음을 확인할 수 있습니다.</p>
<p>Graphviz를 통해 시각화 한 그래프를 확인해보면 의존성을 더욱 확실히 알 수 있습니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-graph-graphviz.png" alt="Graphviz로 시각화 한 terraform graph" title="Graphviz로 시각화 한 terraform graph">
<p><code>terraform graph</code> 명령에 대해 더 자세히 알기 원하신다면,<br><a href="https://www.terraform.io/docs/commands/graph.html" target="_blank" rel="external">Terraform 공식 문서</a>를 참고해보세요.</p>
<h4 id="의존성이-없는-리소스-Non-Dependent-Resources"><a href="#의존성이-없는-리소스-Non-Dependent-Resources" class="headerlink" title="의존성이 없는 리소스 (Non-Dependent Resources)"></a>의존성이 없는 리소스 (Non-Dependent Resources)</h4><p>우리는 이제 다른 EC2 인스턴스를 구성해 인프라를 늘릴 수도 있습니다.</p>
<p>다른 리소스에 대해 의존성이 없다면, 해당 리소스는 병렬로 (동시에) 생성될 수 있음을 뜻하기도 합니다.</p>
<p>이번에는 Ubuntu 16.04 AMI를 사용하는 <code>another</code> 라는 이름을 가진 새로운 EC2 인스턴스 리소스를 정의해보겠습니다.</p>
<p>기존 환경설정 파일에 다음 리소스를 추가하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">resource &quot;aws_instance&quot; &quot;another&quot; &#123;</div><div class="line">  ami           = &quot;ami-f293459c&quot;</div><div class="line">  instance_type = &quot;t2.micro&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/15c78a2a3098fc67274a226ae8150666.js"></script>

<p><code>terraform graph</code> 명령을 실행해보면 다음과 같이 <code>aws_intance.another</code> 리소스에는 아무런 의존성이 없고,<br>이는 병렬로 (동시에) 생성될 수 있을 것 같이 보입니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-graph-with-non-dependent-resource.png" alt="terraform graph (with non-dependent resource)" title="terraform graph (with non-dependent resource)">
<p>이번 그래프 역시 Graphviz로 시각화 해보면 다음과 같을 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-graph-graphviz-with-non-dependent-resource.png" alt="Graphviz로 시각화 한 terraform graph" title="Graphviz로 시각화 한 terraform graph">
<p>더욱 눈에 잘 들어오죠?</p>
<p>자, 이번에는 <code>terraform destroy</code> 명령으로 인프라를 제거합시다. (네, 모든 리소스를 삭제할겁니다!)<br>왜냐하면 인프라를 제거하고 <code>terraform apply</code> 명령을 통해 새롭게 인프라를 생성할때, 병렬로 EC2 인스턴스가 생성되는 것을 보려고 하거든요!</p>
<p>아까 배운대로 <code>terraform plan -destroy</code> 명령으로 인프라 제거시 발생하는 변경사항을 검토하고,<br><code>terraform destroy</code> 명령을 통해 인프라를 제거합니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-destroy-for-review-pararrel.png" alt="인프라를 제거하고!" title="인프라를 제거하고!">
<p>그 다음 <code>terraform plan</code> 명령으로 새롭게 생성할 인프라를 검토해보고,</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-for-review-pararrel.png" alt="새롭게 만드는 인프라 검토하고!" title="새롭게 만드는 인프라 검토하고!">
<p>마지막으로 <code>terraform apply</code> 명령을 통해 병렬로 (동시에) EC2 리소스가 생성되는지 확인해봅니다!</p>
<img src="/2016/12/19/Terraform-101/terraform-apply-for-review-pararrel.png" alt="동시에 EC2 인스턴스 생성" title="동시에 EC2 인스턴스 생성">
<p>우와!!! <code>terraform apply</code> 명령을 실행하는 동안, Terraform이 정말 병렬로 EC2 인스턴스를 생성하는것을 확인할 수 있습니다!</p>
<p>어때요? 멋지죠!?</p>
<h4 id="다음-섹션으로-넘어가기-전에…"><a href="#다음-섹션으로-넘어가기-전에…" class="headerlink" title="다음 섹션으로 넘어가기 전에…"></a>다음 섹션으로 넘어가기 전에…</h4><p>다음 섹션으로 넘어가기 전에 Terraform 환경설정 파일에서 방금 만들었던 <code>another</code> EC2 인스턴스 리소스를 제거하고 <code>terraform destroy</code> 명령을 다시 실행해 인프라를 제거하세요.<br>왜냐하면 이제 <code>another</code> 리소스를 쓸 일이 없고, 다음 장에서 소개하는 프로비저닝은 인스턴스가 생성되는 시점에만 동작하기 때문입니다.</p>
<p>여기까지 따라오시는 동안 인프라를 만들고 삭제하는건 많이 해보셨을 것이기 때문에, 이번에는 따로 스크린샷을 첨부하진 않습니다.<br>(사실 귀찮아서… ㅠㅠ)<br>이번에 <code>terraform destroy</code> 명령을 실행할 때에는 <code>terraform apply</code> 명령을 실행했을 때와는 반대로 Elastic IP가 먼저 삭제되는 것을 확인하실 수 있으실 겁니다 :)</p>
<p>이번 섹션에서는 복수 리소스를 정의하는 것과 함께 기본적인 리소스 의존성, 그리고 템플릿(interpolation)을 통한 속성 참조를 소개했습니다.<br>다음 섹션에서는, Provision을 사용해 우리가 실행한 인스턴스에 기본적인 bootstrapping을 수행하는 방법을 알아보도록 하겠습니다.</p>
<h2 id="프로비저닝-Provision"><a href="#프로비저닝-Provision" class="headerlink" title="프로비저닝 (Provision)"></a>프로비저닝 (Provision)</h2><p>여기까지 오신 여러분들은 인프라를 생성하고 수정하는건 이제 꽤 익숙해졌을겁니다.<br>이번에는 프로비저너(Provisioner)들을 사용하여 인스턴스들이 생성된 후 어떻게 해당 인스턴스들을 초기화 (initialize) 할 수 있는지에 대해 알아볼 것입니다.</p>
<p>만약 여러분들이 이미지 기반의 인프라 (아마 <a href="https://www.packer.io/" target="_blank" rel="external">Packer</a>로 생성한 이미지)를 이미 사용하고 있다면,<br>지금까지 알아본 내용으로도 충분할 것입니다. </p>
<p>하지만 인스턴스들에 초기 설정 (initial setup)을 하기 원한다면, 프로비저너(Provisioner)를 사용해 파일을 업로드하고, 쉘 스크립트를 실행하고, 설정 관리을 위한 소프트웨어 같은 것들을 설치하고 실행하도록 여러분을 도울 것입니다.</p>
<h4 id="프로비저너-정의하기-Defining-a-Provisioner"><a href="#프로비저너-정의하기-Defining-a-Provisioner" class="headerlink" title="프로비저너 정의하기 (Defining a Provisioner)"></a>프로비저너 정의하기 (Defining a Provisioner)</h4><p>프로비저너 (Provisioner)를 정의하기 위해서는,<br>이전에 설정한 Terraform 설정 파일에서 <code>example</code> EC2 인스턴스의 리소스를 다음처럼 변경하면 됩니다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</div><div class="line">  ami           = &quot;ami-983ce8f6&quot;</div><div class="line">  instance_type = &quot;t2.micro&quot;</div><div class="line"></div><div class="line">  provisioner &quot;local-exec&quot; &#123;</div><div class="line">    command = &quot;echo $&#123;aws_instance.example.public_ip&#125; &gt; ip_address.txt&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/12fa08f71c06078eb6ccbeae300ef90f.js"></script>

<p>여러분들은 리소스 블럭 내부에 프로비저너(Provisioner) 블럭이 새롭게 추가된 것을 확인하실 수 있을겁니다.<br>이전 섹션에서 여러 리소스를 정의해서 사용할 수 있었던 것 처럼, 프로비저너(Provisioner) 역시 복수개를 정의하여 여러 단계의 프로비저닝 과정을 구성할 수 있습니다.</p>
<p>Terraform은 <a href="https://www.terraform.io/docs/provisioners/" target="_blank" rel="external">여러 종류의 프로비저너(Provisioner)를 지원</a>하지만,<br>일단 이번 예제에서는 <code>local-exec</code> 프로비저너(Provisioner)만을 사용해보도록 하겠습니다.</p>
<p>이 <code>local-exec</code> 프로비저너(Provisioner)는 다른 프로비저너들과는 다르게 인스턴스 접속에 필요한 정보들 (e.g. SSH Key, Username, Password)에 대해 신경쓰지 않아도 되거든요.</p>
<p><code>local-exec</code> 프로비저너(Provisioner)는 The local-exec provisioner Teraform을 실행하고 있는 로컬 머신에서 명령을 실행하는 역할을 합니다.</p>
<p>위의 프로비저너 스니펫은 <code>example</code> EC2 인스턴스에 할당된 Elastic IP를 <code>ip_address.txt</code> 파일로 출력합니다.</p>
<h4 id="프로비저너-실행하기-Running-Provisioners"><a href="#프로비저너-실행하기-Running-Provisioners" class="headerlink" title="프로비저너 실행하기 (Running Provisioners)"></a>프로비저너 실행하기 (Running Provisioners)</h4><p>프로비저너들은 리소스가 생성될때만 동작합니다.<br>이미 실행중인 서버에 대해 구성을 관리하고 소프트웨어를 변경하기 위해 프로비저너를 사용하는 것은 올바르지 않습니다.<br>그냥 서버를 부트스트랩(bootstrap)하는 방법이라고 생각하세요.</p>
<p>서버에 대한 구성 관리 (configuration management)가 필요하다면,<br><strong>진짜</strong> 구성 관리 솔루션을 실행시키기 위한 수단으로 Terraform 프로비저닝을 사용하세요!</p>
<p>기존에 생성한 인프라가 제거되었는지 다시 한번 확인하고, <code>terraform apply</code> 명령을 실행하세요:</p>
<img src="/2016/12/19/Terraform-101/terraform-apply-with-provisoner.png" alt="terraform apply (with local-exec provisioner)" title="terraform apply (with local-exec provisioner)">
<p>짠! Terraform이 EC2 인스턴스를 생성하고, <code>local-exec</code> 프로비저너가 동작하는 것을 확인하실 수 있습니다.</p>
<p>Terraform은 프로비저너들의 모든 출력을 콘솔에 표시하지만, 이번에는 redirection으로 인해 출력 결과가 보이지 않을 겁니다.<br>그래서 <code>ip_address.txt</code> 파일을 확인해 <code>local-exec</code> 프로비저너가 잘 동작했는지 검증해보도록 하죠.</p>
<p><code>cat ip_address.txt</code> 명령과 <code>terraform show | grep ip</code>  명령을 각각 실행해보고, 결과를 비교해보세요:</p>
<img src="/2016/12/19/Terraform-101/terraform-provisoner-local-exec-result.png" alt="local-exec 프로비저너 검증" title="local-exec 프로비저너 검증">
<p>우리가 요구한대로, 해당 Elastic IP의 Public IP가 해당 텍스트 파일에 잘 들어간 것을 확인할 수 있습니다!</p>
<h4 id="실패한-프로비저너와-더럽혀진-리소스-Failed-Provisioners-and-Tainted-Resources"><a href="#실패한-프로비저너와-더럽혀진-리소스-Failed-Provisioners-and-Tainted-Resources" class="headerlink" title="실패한 프로비저너와 더럽혀진 리소스 (Failed Provisioners and Tainted Resources)"></a>실패한 프로비저너와 더럽혀진 리소스 (Failed Provisioners and Tainted Resources)</h4><p>만일 리소스는 성공적으로 만들었지만 프로비저닝이 실패한다면, Teraform은 에러를 뱉고 해당 리소스를 <code>tainted</code> (더럽혀진 리소스)로 표기할 것입니다.</p>
<p><code>tainted</code> 상태로 표시되는 리소스는 물리적으론 생성된 상태이지만, 프로비저닝이 실패했기 때문에 사용하기에 안전하다고 여길수 없습니다.</p>
<p>프로비저닝이 실패한 상태에서 (리소스가 <code>tainted</code> 상태일 때) 여러분들이 다음 실행 계획 (execution plan)을 생성한다면 (<code>terraform plan</code> 명령을 실행한다면),<br>Terraform은 해당 리소스가 사용하기에 안전하다고 개런티 할 수 없기 때문에 프로비저닝에 실패한 해당 리소스에 대해 프로비저닝을 다시 시도하지 않습니다.<br>대신 해당 <code>tainted</code> 상태의 리소스를 삭제하고 다시 리소스를 생성한 뒤 프로비저닝을 다시 시도합니다.</p>
<p>Terraform은 또한 <code>apply</code> 단계에서 프로비저닝 실패시 자동으로 작업한 내용을 롤백(rollback)하고 해당 리소스를 제거하지 않습니다.<br>그냥 <code>tainted</code> 상태로 마크만 해 둘것입니다.<br>왜냐하면, 실행 계획 (Execution Plan)에서 생성한 계획은 리소스를 ‘생성’ 한다는 것이었지, ‘삭제’ 하는건 아니었기 때문입니다.<br>만약 롤백을 위해 리소스를 ‘삭제’하게 된다면, 이는 실행 계획의 존재 목적에 반하게 되는 것이기도 합니다.</p>
<p>대신 만약 여러분이 <code>tainted</code> 상태의 리소스가 존재하는 상태에서 새로운 실행 계획을 만든다면 (<code>terraform plan</code> 명령을 실행한다면),<br>새롭게 만들어진 실행 계획에서는 깨끗한 상태를 위해서 <code>tainted</code> 상태의 해당 리소스를 삭제하도록 할 것입니다.</p>
<h4 id="다음"><a href="#다음" class="headerlink" title="다음"></a>다음</h4><p>프로비저닝은 인스턴스를 부트스트랩(bootstrap)이 가능하게 하기 때문에 중요합니다.</p>
<p>다시 한번 말씀드리지만, Terraform에서의 프로비저닝은 구성 관리(configuration management)를 대체하는 위한 것이 아닙니다.<br>그냥 머신을 처음 쓰기 위해 부트스트랩(bootstrap)하는거에요.</p>
<p>여러분들이 구성 관리(configuration management)를 사용한다면,<br>Terraform에서의 프로비저닝은 구성 관리 도구(configuration management tool)를 부트스트랩(bootstrap) 하기 위한 수단으로 사용하셔야 합니다.</p>
<p>다음 섹션에서 우리는 설정을 파라미터화(parameterize) 하기 위해 변수(variable)를 알아볼 것입니다.</p>
<h2 id="입력-변수-Input-Variables"><a href="#입력-변수-Input-Variables" class="headerlink" title="입력 변수 (Input Variables)"></a>입력 변수 (Input Variables)</h2><p>여러분들은 유용한 설정들을 만들기 위한 Terraform 지식을 충분히 얻었습니다.<br>하지만 우리는 아직도 액세스 키 (Access Key), AMI와 같은 정보를 설정파일에 직접 기입(hard-coding)해야 합니다.</p>
<p>Terraform 설정을 공유할 수 있고, 버전관리 할 수 있게하려면, 우리는 설정을 ‘파라미터화’ (parameterize) 해야합니다.<br>이번 섹션에서는 이를 가능하게하는 입력 변수에 대해 소개할 것입니다.</p>
<h4 id="변수-정의하기-Defining-Variables"><a href="#변수-정의하기-Defining-Variables" class="headerlink" title="변수 정의하기 (Defining Variables)"></a>변수 정의하기 (Defining Variables)</h4><p>첫번째로 우리가 만들었던 설정 파일에서 AWS 액세스 키 (access key), 비밀 키 (secret key), 그리고 리전 정보를 변수들로 뽑아내 봅시다.</p>
<p><code>example.tf</code> 설정 파일을 만들었던 디렉토리에서 아래 내용을 <code>variables.tf</code> 파일로 저장하세요.</p>
<blockquote>
<p>참고: Terraform은 작업 디렉토리 (Working directory) 내의 모든 <code>.tf</code> 파일을 불러오기 때문에, 파일명은 원하는 이름을 써도 됩니다. 여기선 그냥 편의를 위해서 <code>variables.tf</code>를 쓸 뿐입니다.</p>
</blockquote>
<script src="https://gist.github.com/mooyoul/d28993544eb0bec8bd939c7a8af21edf.js"></script>

<p>위 스니펫은 Terraform 환경설정 내에 세개의 변수를 정의합니다.<br>처음 두 변수(access_key, secret_key)들은 빈 블럭(<code>{}</code>)을 가지고 있고,<br>세번째 변수는 기본값(<code>default = &quot;ap-northeast-2&quot;</code>)을 설정했습니다.</p>
<p>만약 기본값이 설정되어 있으면, 해당 변수는 선택항목(optional) 입니다.<br>반대로 기본값이 설정되어 있지 않으면, 해당 변수는 필수항목(required)가 되겠죠.</p>
<p>이 상태에서 <code>terraform plan</code> 명령을 실행하면, 아래 화면처럼 Terraform이 할당되지 않은 변수에 입력할 값을 물어볼 것입니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-asking-variable.png" alt="terraform plan 명령 실행시 할당되지 않은 값에 대한 질문" title="terraform plan 명령 실행시 할당되지 않은 값에 대한 질문">
<h4 id="환경설정에서-변수-사용하기-Using-Variables-in-Configuration"><a href="#환경설정에서-변수-사용하기-Using-Variables-in-Configuration" class="headerlink" title="환경설정에서 변수 사용하기 (Using Variables in Configuration)"></a>환경설정에서 변수 사용하기 (Using Variables in Configuration)</h4><p>이번엔 AWS Provider 설정을 다음과 같이 변경하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">provider &quot;aws&quot; &#123;</div><div class="line">  access_key = &quot;$&#123;var.access_key&#125;&quot;</div><div class="line">  secret_key = &quot;$&#123;var.secret_key&#125;&quot;</div><div class="line">  region     = &quot;$&#123;var.region&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의  <code>example.tf</code> 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/a68903a8d7cb5dc747b70cf201b47677.js"></script>

<p>위 스니펫은 더 많은 템플릿 표기법(interpolations)을 사용합니다.<br>이전에 리소스를 참조했던 것과는 다르게, 이번에는 <code>var.</code> 접두사를 사용합니다.<br>이는 Terraform에게 변수에 접근하려는 것임을 알려주게 됩니다.<br>즉, 위 스니펫은 지정한 변수를 사용해 AWS Provider를 구성할 수 있도록 합니다.</p>
<h4 id="변수에-값-할당하기-Assigning-Variables"><a href="#변수에-값-할당하기-Assigning-Variables" class="headerlink" title="변수에 값 할당하기 (Assigning Variables)"></a>변수에 값 할당하기 (Assigning Variables)</h4><p>변수에 값을 할당하는 방법은 여러가지 방법이 있습니다.<br>아래에서 소개하는 각 방법들은 어떤 순서로 변수의 값을 선택되는지에 대한 순서이기도 합니다.</p>
<p>즉, 아래는 내림차순으로 된 변수를 선택할 때 고려되는 우선순위입니다 (아래로 갈수록 우선순위 낮음)</p>
<h5 id="명령줄-플래그-Command-line-flags"><a href="#명령줄-플래그-Command-line-flags" class="headerlink" title="명령줄 플래그 (Command-line flags)"></a>명령줄 플래그 (Command-line flags)</h5><p>여러분은 명령줄(command-line)에서 <code>-var</code> 플래그를 통해 변수의 값을 직접 할당하실 수 있습니다.<br><code>apply</code>, <code>plan</code>, <code>refresh</code>와 같이 환경설정을 읽는 Terraform의 명령이라면 <code>-var</code> 플래그를 사용할 수 있습니다.</p>
<p>아래는 명령줄 플래그로 변수의 값을 할당하는 예제입니다:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ terraform plan \</div><div class="line">  -var <span class="string">'access_key=foo'</span> \</div><div class="line">  -var <span class="string">'secret_key=bar'</span></div></pre></td></tr></table></figure>
<p>다만 이 방법으로 변수에 값을 할당한다면 해당 값들은 저장되지 않기 때문에, Terraform의 명령들을 실행할때마다 반복해서 입력해야만 합니다.</p>
<h5 id="파일에서-읽기-From-a-file"><a href="#파일에서-읽기-From-a-file" class="headerlink" title="파일에서 읽기 (From a file)"></a>파일에서 읽기 (From a file)</h5><p>변수의 값들을 쭉 보존하고 싶다면, 파일을 하나 만들어서 안에 값들을 집어넣는 방법을 써도 됩니다.<br>아래처럼 <code>terraform.tfvars</code> 이름을 가진 파일을 만들기만 하면 됩니다:</p>
<script src="https://gist.github.com/mooyoul/339f994caf90f9e776e5e9d2fbb71382.js"></script>

<p>만약 현재 작업 디렉토리에 <code>terraform.tfvars</code> 파일이 존재한다면,<br>Terraform은 자동으로 해당 파일을 읽어 변수에 값을 할당합니다.</p>
<p>만약 변수 값을 가진 파일이 <code>terraform.tfvars</code>가 아니라면,<br>여러분은 <code>-var-file</code> 플래그를 사용해 직접 읽어올 파일을 지정할 수 있습니다.</p>
<p>또한 이 파일은 이전에 Terraform 설정 파일 (<code>.tf</code>)과 동일하게 HCL(Hashicorp Configuration Language)를 사용하고,<br>Terraform 설정 파일처럼 JSON으로도 작성해서 사용하실 수 있습니다.</p>
<p>Terraform은 사용자 아이디 (username)과 비밀번호를 버전 관리 시스템에 저장하는것을 권장하지 않습니다.<br>하지만, 여러분들은 로컬에 비밀 변수 파일(secret variables file)을 만들고 <code>-var-file</code> 플래그를 통해 사용할 수 있습니다.<br>그리고 한 명령에서 복수개의 <code>-var-file</code> 플래그를 사용할 수 있습니다.</p>
<p>가령 버전 관리 시스템에 어떤건 체크인되고 어떤건 체크인되지 않는 상황이라면 다음과 같을 것입니다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ terraform plan \</div><div class="line">  -var-file=&quot;secret.tfvars&quot; \</div><div class="line">  -var-file=&quot;production.tfvars&quot;</div></pre></td></tr></table></figure>
<h5 id="환경변수에서-읽기-From-environment-variables"><a href="#환경변수에서-읽기-From-environment-variables" class="headerlink" title="환경변수에서 읽기 (From environment variables)"></a>환경변수에서 읽기 (From environment variables)</h5><p>Terraform은 변수의 값을 찾기 위해 <code>TF_VAR_${name}</code> 형식의 이름을 가진 환경변수 또한 읽을 것입니다.<br>예를 들면, <code>TF_VAR_access_key</code> 라는 이름의 환경변수가 존재한다면 Terraform은 <code>access_key</code> 라는 이름의 변수의 값으로 해당 환경변수의 값을 할당합니다.<br>(<code>TF_VAR_access_key=foo</code> 인 경우 <code>access_key</code>의 값으로 <code>foo</code> 할당)</p>
<blockquote>
<p>참고: 환경변수는 오직 문자열 형식으로만 변수 값을 할당합니다.<br>리스트(List)와 맵(Map) 타입의 변수을 할당하고 싶다면, 다른 매커니즘을 사용해 값을 할당해야 합니다.</p>
</blockquote>
<h5 id="UI-입력-UI-Input"><a href="#UI-입력-UI-Input" class="headerlink" title="UI 입력 (UI Input)"></a>UI 입력 (UI Input)</h5><p>만약 여러분이 아무것도 하지 않고 (값 할당 없이) <code>terraform plan</code> 명령이나 <code>terraform plan</code> 명령을 실행한다면,<br>아래와 같이 Terraform은 사용자에게 값을 입력하도록 물어볼 것입니다. </p>
<p>이전에 언급했듯, 이 방법은 값이 저장되지 않습니다. 하지만 Terraform을 처음 사용하는 사용자에게는 좋은 사용자 경험이 될 것입니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-asking-variable.png" alt="terraform plan 명령 실행시 할당되지 않은 값에 대한 질문" title="terraform plan 명령 실행시 할당되지 않은 값에 대한 질문">
<blockquote>
<p>참고: UI 입력은 환경변수와 동일하게 오직 문자열 형식으로만 변수 값을 할당합니다.<br>리스트(List)와 맵(Map) 타입의 변수을 할당하고 싶다면, 다른 매커니즘을 사용해 값을 할당해야 합니다.</p>
</blockquote>
<h5 id="변수-기본값-Variable-Defaults"><a href="#변수-기본값-Variable-Defaults" class="headerlink" title="변수 기본값 (Variable Defaults)"></a>변수 기본값 (Variable Defaults)</h5><p>만약 위에서 소개한 방법 중 그 어떤 곳에서도 변수의 값을 할당하는 곳이 없고, 정의한 변수가 기본값을 가지고 있다면 해당 기본값을 변수에 할당합니다.</p>
<h4 id="리스트-Lists"><a href="#리스트-Lists" class="headerlink" title="리스트 (Lists)"></a>리스트 (Lists)</h4><p>리스트는 명시적으로도 정의할 수 있고 암묵적으로도 정의할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># brackets 표기를 사용해 암묵적으로 리스트 타입 정의</div><div class="line">variable &quot;cidrs&quot; &#123; default = [] &#125;</div><div class="line"></div><div class="line"># 리스트 타입 명시</div><div class="line">variable &quot;cidrs&quot; &#123; type = &quot;list&quot; &#125;</div></pre></td></tr></table></figure>
<p>여러분들은 <code>terraform.tfvars</code> 파일에서 리스트의 값들을 할당하실 수 있습니다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cidrs = [ &quot;10.0.0.0/16&quot;, &quot;10.1.0.0/16&quot; ]</div></pre></td></tr></table></figure>
<h4 id="맵-Maps"><a href="#맵-Maps" class="headerlink" title="맵 (Maps)"></a>맵 (Maps)</h4><p>우리는 기존 환경설정 내의 민감한 정보들(API Key나 Secret Key 같은)을 변수를 사용하도록 교체했습니다.<br>하지만, AMI의 경우에는 아직까지 직접 기입하고 있죠.<br>불행하게도, AMI는 사용중인 리전에 따라 지정되어야 합니다. (서울 리전에서의 Ubuntu 16.04 LTS AMI와 버지니아 리전의 Ubuntu 16.04 LTS AMI의 AMI ID가 다르거든요)</p>
<p>한가지 옵션으로 그냥 유저에게 리전에 적합한 AMI를 직접 입력하도록 묻는 것이 있겠지만, Terraform은 맵(Map)을 사용해 그거보다 더 나은 방법으로 문제를 해결할 수 있습니다.    </p>
<p>맵(Map)은 테이블에서 특정 키로 값을 찾아 변수에 할당하기 위한 방법입니다.<br>아래 예제는 이를 정말 잘 보여줍니다. 우리의 AMI들을 맵으로 추출하고 <code>us-west-2</code> 리전을 지원해보도록 만들어 봅시다.</p>
<p>다음 내용을 <code>variables.tf</code> 파일에 추가하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">variable &quot;amis&quot; &#123;</div><div class="line">  type = &quot;map&quot;</div><div class="line">  default = &#123;</div><div class="line">    ap-northeast-2 = &quot;ami-983ce8f6&quot;</div><div class="line">    us-west-2 = &quot;ami-06b94666&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후 <code>variables.tf</code> 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/13e4241125cd98dd2ff9cc1fb8054127.js"></script>


<p>Map 타입의 변수는 명시적으로 정의할 수 있고,<br>아니면 기본 값에 Map 타입의 값을 지정함으로써 해당 변수의 타입이 맵이라는 것을 알려 암묵적으로 정의할수도 있습니다.<br>위 예제에서는 두 경우 모두를 포함합니다.</p>
<p>자, 그럼 <code>example.tf</code>의 <code>aws_instance</code> 리소스를 다음처럼 변경하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</div><div class="line">  ami           = &quot;$&#123;lookup(var.amis, var.region)&#125;&quot;</div><div class="line">  instance_type = &quot;t2.micro&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 <code>example.tf</code>의 코드는 다음과 같습니다:</p>
<script src="https://gist.github.com/mooyoul/2f16311eab27fa5cb0efb039e6b6a86a.js"></script>

<p>이번에 새로운 방식의 템플릿 표기(interpolation)를 보실 겁니다. 바로 함수 호출이죠.<br><code>lookup</code> 함수는 동적으로 맵의 특정 키의 값을 찾아봅니다.<br>위 스니펫 기준으로는 <code>var.amis</code> 맵에서 <code>var.region</code>의 값을 키로 사용하여 값을 찾아봅니다.</p>
<p>지금 위 예제에서는 사용하지 않지만, <code>${var.amis[&quot;ap-northeast-2&quot;]}</code>를 통해 정적 참조도 가능한 것을 알아두세요.</p>
<h4 id="맵-할당하기-Assigning-Maps"><a href="#맵-할당하기-Assigning-Maps" class="headerlink" title="맵 할당하기 (Assigning Maps)"></a>맵 할당하기 (Assigning Maps)</h4><p>우리는 위에서 기본 값을 정의했지만, 맵 또한 <code>-var</code> 와 <code>-var-file</code> 플래그를 통해 맵에 대한 값을 할당할 수 있습니다.</p>
<p>예를 들면 다음과 같습니다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ terraform plan -var &apos;amis=&#123; ap-northeast-2 = &quot;foo&quot;, us-west-2 = &quot;bar&quot; &#125;&apos;</div></pre></td></tr></table></figure>
<blockquote>
<p>참고: <code>-var</code> 플래그를 통해 맵을 할당할 수 있지만,<br>할당하려는 해당 변수의 기본값을 <code>{}</code>으로 설정해 타입을 암시적으로 설정하거나 <code>type = map</code>을 통해 명시적으로 타입을 정의하여야 합니다.<br>그렇게 하지 않으면, Terraform은 문자열 타입의 변수로 간주하기 때문에 에러를 출력할 것입니다.</p>
</blockquote>
<p>아래는 파일을 파일에서 맵을 정의하고, 맵의 값을 정의하고, 맵을 조회해보는 예제입니다. 먼저 변수를 정의하는 것부터 시작하죠.<br>아직 <code>example.tf</code> 파일이 있는 디렉토리에 계시다면, <code>map-playground</code> 라는 이름의 새로운 디렉터리를 생성하고<br>해당 디렉토리로 들어간 후 변수를 정의하기 위해 아래 내용으로 <code>variables.tf</code> 파일을 새로 만들어봅시다.<br>(이전에도 말씀드렸듯이 Terraform은 현재 작업 디렉토리 (Working directory)내의 모든 <code>.tf</code> 파일을 찾아서 불러들이기 떄문에, 동일한 디렉터리에 새로 설정파일을 생성하게되면 이전 예제와 설정이 섞일 수 있습니다. 이를 방지하기 위해 디렉토리를 새로 만드는 것입니다.) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">variable &quot;region&quot; &#123;&#125;</div><div class="line">variable &quot;amis&quot; &#123;</div><div class="line">  type = &quot;map&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>그리고, 변수를 정의했으니 값을 할당해줘야겠죠? 이번에는 맵에 대한 값을 파일로 저장합니다.<br>다음 내용을 <code>terraform.tfvars</code> 파일로 저장하세요.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">amis = &#123;</div><div class="line">  ap-northeast-2 = &quot;ami-983ce8f6&quot;</div><div class="line">  us-west-2 = &quot;ami-def456&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>마지막으로, 다음 내용을 <code>output.tf</code> 파일로 저장하세요.<br>아래 스니펫은 <code>lookup</code> 함수를 사용해 <code>amis</code> 맵에서 <code>region</code> 변수의 값을 키로 사용하여 값을 찾아 출력할 것입니다.<br><code>output</code>이 무얼 뜻하는지 더 궁금하시겠지만, 일단은 조금만 참으세요. 다음 섹션에서 설명할겁니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">output &quot;ami&quot; &#123;</div><div class="line">  value = &quot;$&#123;lookup(var.amis, var.region)&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>자, 그럼 <code>terraform apply -var region=us-west-2</code> 명령을 실행해보세요:</p>
<img src="/2016/12/19/Terraform-101/terraform-map.png" alt="region에 따라 ami가 다른걸 보세요!" title="region에 따라 ami가 다른걸 보세요!">
<p>region에 따라 ami가 다르게 출력되는 것을 확인하실 수 있습니다!</p>
<h4 id="다음-1"><a href="#다음-1" class="headerlink" title="다음"></a>다음</h4><p>Terraform은 여러분들의 설정을 파라미터화하기 위한 변수를 제공합니다.<br>맵은 여러분들이 조건에 따라 테이블의 값들을 찾아볼 수 있도록 할 것입니다.</p>
<p>다음 장부터는 위에서 맵을 사용해보기 위해 새롭게 만든 디렉토리와 환경설정들을 더이상 필요로 하지 않습니다.<br><code>map-playground</code> 디렉토리와 디랙토리 내의 모든 파일들을 삭제하고,<br>이전에 EC2 인스턴스와 Elastic IP를 정의했던 Terraform 설정파일이 있는 디렉토리로 다시 되돌아가세요.</p>
<h2 id="출력-변수-Output-Variables"><a href="#출력-변수-Output-Variables" class="headerlink" title="출력 변수 (Output Variables)"></a>출력 변수 (Output Variables)</h2><p>이전 섹션에서 입력 변수(input variables)를 Terraform 구성 설정을 파라미터화(parameterize) 하는 방법으로 소개했습니다.<br>이번 섹션에서는 출력 변수(output variables)를 Terraform 유저가 데이터를 쉽게 질의하고 볼 수 있도록 관리하는 방법으로 소개할 것입니다.</p>
<p>잠재적으로 복잡한 인프라를 만들때, Terraform은 여러분들의 모든 리소스에 대한 100~1000개의 속성 값들을 저장합니다.<br>하지만 Terraform를 사용하는 유저는 로드 밸런서 IP, VPN 주소와 같은 오직 몇가지의 중요한 속성 값만 관심을 가지고 있을 것입니다.</p>
<p>출력 변수는 Terraform에게 어떤 정보가 중요한지 알리는 방법입니다.<br>출력 변수로 지정한 데이터는 <code>terraform apply</code> 명령을 실행하면 출력되고, <code>terraform output</code> 명령을 사용해 질의할 수도 있습니다.</p>
<h4 id="출력-변수-정의하기-Defining-Outputs"><a href="#출력-변수-정의하기-Defining-Outputs" class="headerlink" title="출력 변수 정의하기 (Defining Outputs)"></a>출력 변수 정의하기 (Defining Outputs)</h4><p>이전에 우리가 생성한 Elastic IP 리소스의 공인 IP(Public IP)를 보기 위해 출력 변수를 정의해봅시다.</p>
<p><code>example.tf</code> 파일을 열어서 아래 내용을 추가하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">output &quot;ip&quot; &#123;</div><div class="line">    value = &quot;$&#123;aws_eip.ip.public_ip&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/3622099b93a14fe660291fc6a86614a9.js"></script>

<p>위 스니펫은 <code>ip</code>라는 이름의 출력 변수를 정의합니다. <code>value</code> 필드는 해당 출력 변수가 어떤 값을 가질지를 정의하고, 거의 항상 하나 이상의 템플릿 표기법(interpolations)들을 가지고 있습니다. 대부분의 값들은 동적이기 때문이죠.<br>이번 경우에는 Elastic IP 리소스의 <code>public_ip</code> 속성을 값으로 출력할 것입니다.</p>
<p>여러개의 출력 변수를 정의하기 위해 복수의 <code>output</code> 블럭을 사용할 수도 있습니다.</p>
<h4 id="출력-변수-확인하기-Viewing-Outputs"><a href="#출력-변수-확인하기-Viewing-Outputs" class="headerlink" title="출력 변수 확인하기 (Viewing Outputs)"></a>출력 변수 확인하기 (Viewing Outputs)</h4><p>출력 변수에 값을 채워넣기 위해 <code>terraform apply</code> 명령을 실행해보세요. 출력 변수를 정의했다면 반드시 한번 해야 합니다.</p>
<p>아마 명령을 실행한 결과가 이전과 조금 다를겁니다.<br>이렇개 실행 결과의 끝 부분을 보시면 여러분이 지정한 출력 변수를 확인하실 수 있죠:</p>
<img src="/2016/12/19/Terraform-101/terraform-apply-with-output-variables.png" alt="terraform apply" title="terraform apply">
<p><code>terraform apply</code> 명령은 출력 변수의 값들을 강조해 보여줍니다.</p>
<p>또한 여러분들은 <code>terraform apply</code> 명령을 수행해 출력 변수에 값을 할당한 이후부터 <code>terraform output [NAME]</code> 명령을 사용해 출력 변수의 값을 질의할 수 있습니다.</p>
<p>별도로 출력 변수의 이름을 인자로 넘기지 않은 경우 (<code>terraform output</code> 명령을 실행한 경우), Terraform은 모든 출력 변수의 이름과 값을 출력할 것입니다.<br>반대로 출력 변수의 이름을 인자로 넘기는 경우 (<code>terraform output ip</code>), Teraform은 해당 이름의 출력 변수의 값만을 출력합니다.</p>
<p><code>terraform output</code>, <code>terraform output ip</code> 명령을 각각 실행해 결과를 비교해보세요:</p>
<img src="/2016/12/19/Terraform-101/terraform-output.png" alt="terraform output" title="terraform output">
<p>이 명령은 스크립트(e.g. 쉘 스크립트)에서 출력 변수의 값을 추출할 때 유용하게 사용할 수 있습니다.</p>
<h4 id="다음-2"><a href="#다음-2" class="headerlink" title="다음"></a>다음</h4><p>여러분들은 이제 어떻게 Terraform 환경설정을 입력 변수(input variables)로 파라미터화하고,<br>출력 변수(output variables)로 중요한 데이터를 추출하고, 프로비저너(provisioners)를 사용해 리소스를 부트스트랩(bootstrap)하는지 알겁니다.</p>
<p>다음 섹션에서 우리는 어떻게 모듈(modules)을 사용하고, 구조에 유용한 추상화, 그리고 Terraform 환경설정을 재사용 하는 방법을 알아볼 것입니다.</p>
<p>그동안 가이드를 따라오면서 만들고 수정했던 Terraform 환경설정 파일들과 리소스는 더이상 사용하지 않습니다.<br><code>terraform destroy</code> 명령을 통해 해당 리소스들을 모두 삭제하시고, 모든 환경설정 파일 또한 삭제하세요. 다음 섹션에서 새롭게 Terraform 환경설정을 생성할 것입니다.</p>
<h2 id="모듈-Modules"><a href="#모듈-Modules" class="headerlink" title="모듈 (Modules)"></a>모듈 (Modules)</h2><p>여기까지는 우리는 Terraform을 환경설정을 직접 수정하여 Terraform을 구성했습니다.<br>인프라가 성장함에 따라, 이 방법은 몇가지 문제를 가지고 있습니다: 인프라를 구성하는 구조(organization)의 부재, 재사용성의 부재, 그리고 팀을 위한 관리의 어려움.</p>
<p>Terraform의 모듈은 그룹으로 관리되는 Terraform 설정들을 가지고 있는 패키지(self-contained packages of Terraform configurations)입니다.<br>모듈은 재사용한 컴포넌트를 만들고, 구조를 개선시키며, 인프라를 각 부분을 블랙박스로 처리(to treat pieces of infrastructure as a black box.) 할 수 있습니다.</p>
<p>이 섹션은 모듈을 사용하는 기초를 다룹니다. 모듈을 작성하는 방법은 <a href="https://www.terraform.io/docs/modules/" target="_blank" rel="external">모듈 문서</a>에서 상세히 다루고 있으니 관심이 있으시다면 해당 문서를 참고하시기 바랍니다.</p>
<blockquote>
<p>주의: 이 엑션의 예제들은 AWS 프리 티어에 적용되지 않습니다.<br>조금의 요금이라도 지불할 의사가 없으시다면, 이 섹션의 예제를 실행하지 마세요.</p>
</blockquote>
<h4 id="모듈-사용하기-Using-Modules"><a href="#모듈-사용하기-Using-Modules" class="headerlink" title="모듈 사용하기 (Using Modules)"></a>모듈 사용하기 (Using Modules)</h4><p>아래 예제에서는 완전한 <a href="https://www.consul.io/" target="_blank" rel="external">Consul</a> 클러스터를 구성하는 <a href="https://github.com/hashicorp/consul/tree/master/terraform" target="_blank" rel="external">Consul Terraform 모듈</a>을 사용할 것입니다.  </p>
<p>아래 내용으로 새롭게 Terraform 환경설정 파일을 만드세요.<br>저는 <code>consul-terraform.tf</code> 으로 저장했습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">variable &quot;access_key&quot; &#123;&#125;</div><div class="line">variable &quot;secret_key&quot; &#123;&#125;</div><div class="line">variable &quot;region&quot; &#123;</div><div class="line">  default = &quot;ap-northeast-2&quot;</div><div class="line">&#125;</div><div class="line">variable &quot;key_name&quot; &#123;&#125;</div><div class="line">variable &quot;key_path&quot; &#123;&#125;</div><div class="line"></div><div class="line">provider &quot;aws&quot; &#123;</div><div class="line">  access_key = &quot;$&#123;var.access_key&#125;&quot;</div><div class="line">  secret_key = &quot;$&#123;var.secret_key&#125;&quot;</div><div class="line">  region     = &quot;$&#123;var.region&#125;&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">module &quot;consul&quot; &#123;</div><div class="line">    # source 속성의 원본 값은 아래와 같으나, </div><div class="line">    # 현재 Consul의 Terraform의 AWS 템플릿에 서울 리전 (ap-northeast-2) AMI가 정의되지 않아</div><div class="line">    # AWS 서울 리전으로 사용할 수 없는 문제가 있어 fork한 버전을 대신 사용합니다.</div><div class="line">    # Consul PR URL: https://github.com/hashicorp/consul/pull/2620</div><div class="line">    # 위 PR이 머지된다면, 아래 코드를 사용하셔도 무방합니다.</div><div class="line">    #</div><div class="line">    # source = &quot;github.com/hashicorp/consul/terraform/aws&quot;</div><div class="line"></div><div class="line">    source = &quot;github.com/mooyoul/consul?ref=tf-module-support-aws-seoul//terraform/aws&quot;</div><div class="line">    key_name = &quot;$&#123;var.key_name&#125;&quot;</div><div class="line">    key_path = &quot;$&#123;var.key_path&#125;&quot;</div><div class="line">    region = &quot;$&#123;var.region&#125;&quot;</div><div class="line">    servers = &quot;3&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>전체 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/f71ca268ea8416cc5db212e5153fd136.js"></script>

<blockquote>
<p>참고로 위 <code>provider</code> 블럭은 AWS CLI에서 사용하는 환경변수를 사용한다면 생략할 수 있습니다. 자세한 내용은 <a href="https://www.terraform.io/docs/providers/aws/#argument-reference" target="_blank" rel="external">AWS Provider 문서의 Argument Reference</a>와 <a href="https://www.terraform.io/docs/providers/aws/#environment-variables" target="_blank" rel="external">AWS Provider 문서의 Environment Variables</a>를 참고하세요.<br><strong>중요: 이 Consul 모듈은 기본 VPC를 가지고 있는 AWS 계정을 필요로합니다.</strong></p>
</blockquote>
<p><code>module</code> 블럭은 Terraform에게 모듈을 만들고 관리하도록 알립니다.<br>이전에 봤던 리소스를 정의하는 <code>resource</code> 블럭과 아주 유사하죠.<br>다만 모듈은 리소스와 달리 오직 하나의 논리적 이름 (logical name, 별명으로 생각하시면 됩니다.)만 가지고 있습니다.<br>위 예제에서는 <code>consul</code>이 논리적 이름이 되겠죠.</p>
<p><code>module</code> 블럭 내에 정의된 <code>source</code> 속성은 모듈 내 속성중 유일한 필수 항목입니다.<br><code>source</code> 속성은 Terraform에게 어디서 모듈을 받아올 지 알립니다.<br>Terraform은 여러분들을 위해 모듈들을 자동으로 내려받고 관리해줄 것입니다.</p>
<p>위 예제에서는 모듈을 Github에서 가져오지만, Terraform은 Git, Mercurial, HTTP, 그리고 파일 경로와 같은 다양한 소스들에서 모듈을 받아올 수 있습니다.</p>
<p>이외 다른 설정들은 모듈의 인자(parameter) 입니다. 위 예제에서는 변수를 참조하도록 값을 채워 넣었습니다.</p>
<p>여러분들이 모듈을 정의하고 나서 <code>plan</code>이나 <code>apply</code> 같은 명령을 실행하기 위해서 실행 전에 한번은 모듈을 얻어오는(내려받고 설치하는) 과정이 필요할 것입니다.<br><code>terraform get</code> 명령으로 바로 그 작업을 수행할 수 있습니다. 바로 실행해보세요:</p>
<img src="/2016/12/19/Terraform-101/terraform-get.png" alt="terraform get" title="terraform get">
<p>Terraform이 알아서 모듈을 얻어오는 것을 확인하실 수 있습니다.</p>
<p><code>terraform get</code> 명령은 내려받지 않은 모듈들이 있다면, 내려받지 않은 모듈들을 내려받을 것입니다.<br>기본적으로 <code>terraform get</code> 명령은 업데이트를 확인하지 않습니다. 그렇기 때문에 안전하게 (그리고 빠르게) 여러번 실행할 수 있습니다.<br>만약 업데이트를 확인하고 내려받고 싶으시다면 <code>-u</code> 플래그를 사용하시면 됩니다. Golang을 쓰시는 분들은 뭔가 좀 익숙하시죠?</p>
<h4 id="모듈을-계획하고-적용하기-Planning-and-Apply-Modules"><a href="#모듈을-계획하고-적용하기-Planning-and-Apply-Modules" class="headerlink" title="모듈을 계획하고 적용하기 (Planning and Apply Modules)"></a>모듈을 계획하고 적용하기 (Planning and Apply Modules)</h4><p>모듈들을 내려받았다면, 우리는 이제 <code>plan</code> 명령을 통해 계획을 점검하고  <code>apply</code> 명령을 통해 이를 적용해볼 수 있습니다.<br>여러분들이 <code>terraform plan</code> 명령을 실행한다면 다음과 같은 출력을 볼것입니다:</p>
<script type="text/javascript" src="https://asciinema.org/a/9op10q1bklo3lm4g8x85hg5hk.js" id="asciicast-9op10q1bklo3lm4g8x85hg5hk" async></script>

<p>개념적으로 모듈은 블랙박스(block box)처럼 취급되더라도,<br>게획(plan)에서 Terraform은 모듈이 괸리하는 각 리소스를 보여주므로 계획에서 수행하는 작업에 대한 상세한 정보를 볼 수 있습니다.</p>
<p>만약 여러분들이 줄여진 계획(실행계획) 출력을 원하신다면 <code>-module-depth=number</code> 플래그를 사용해 Terraform이 모듈별로 요약을 출력하도록 할 수 있습니다.</p>
<p>예로 <code>terraform plan -module-depth=0</code> 명령을 실행해보면 이전과 다르게 출력이 줄어든 것을 확인할 수 있습니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-module-depth.png" alt="terraform plan -module-depth=0" title="terraform plan -module-depth=0">
<p>다음은 <code>terraform apply</code> 명령을 실행해 모듈을 만들어봅시다.<br>위에서 경고했듯이, 이 Consul 모듈은 AWS 프리티어에 해당하지 않는 리소스를 생성하기 때문에 약간의 비용이 발생하니 참고하시기 바랍니다.</p>
<p>자, 그럼 <code>terraform apply</code> 명령을 실행해봅시다!</p>
<script type="text/javascript" src="https://asciinema.org/a/1y4k4c0971c0ro8knol1jlazt.js" id="asciicast-1y4k4c0971c0ro8knol1jlazt" async></script>

<p>몇분정도만 기다리면, 세개의 서버로 이루어진 Consul 클러스터가 동작하는 것을 얻을 겁니다!<br>Consul이 어떻게 동작하고, Consul을 어떻게 설치하고, 그리고 Consul을 어떻게 클러스터로 구성하는지 아무런 지식을 가지고 있지 않지만,<br>우리는 단 몇분만에 실제로 돌아가는 Consul 클러스터를 만들었습니다. 짱이죠?</p>
<h4 id="모듈-출력-Module-Outputs"><a href="#모듈-출력-Module-Outputs" class="headerlink" title="모듈 출력 (Module Outputs)"></a>모듈 출력 (Module Outputs)</h4><p>위의 서버와 같은 속성을 설정해 모듈을 파라미터화(parameterize)했던 것처럼, 모듈은 정보를 출력 할 수도 있습니다 (리소스에서 정보를 출력했던 것처럼요).</p>
<p>여러분들은 모듈들이 어떤 출력을 지원하는지 알기 위해서 각 모듈드의 코드나 문서를 참조해야합니다만,<br>이 가이드에서는 그냥 여러분들께 Consul 모듈이 구성된 Consul 서버들에 대한 주소 정보를 가지고있는 <code>server_address</code>라는 이름을 가진 출력값을 가지고 있다는걸 알려드릴겁니다.</p>
<p>이 <code>server_address</code>를 참조하기 위해서 일단 출력 변수에 저장해보도록 하겠습니다.<br>모듈 출력은 출력 변수 뿐만 아니라 다른 리소스(Elastic IP 리소스를 구성할 때 EC2 인스턴스의 ID를 참조했던 것 처럼), 다른 Provider를 구성할 때 등 어디에서든지 참조해 사용할 수 있습니다. </p>
<p>이전에 만들었던 <code>consul-terraform.tf</code> 파일에 아래 내용을 추가하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">output &quot;consul_address&quot; &#123;</div><div class="line">    value = &quot;$&#123;module.consul.server_address&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후 코드는 다음과 같습니다:</p>
<script src="https://gist.github.com/mooyoul/2dcef697470220df05a362ad1688b7b6.js"></script>


<p>모듈 출력을 참조하기 위한 문법은 아주 친숙할겁니다.<br>문법은 <code>${module.NAME.ATTRIBUTE}</code> 입니다.<br><code>NAME</code>은 전에 우리가 할당한 논리적 이름(logical name)이고,<br><code>ATTRIBUTE</code>는 모듈이 출력하는 속성의 이름입니다. <code>server_address</code>가 이에 해당하겠죠.</p>
<p>여러분들이 <code>terraform apply</code> 명령을 다시 실행한다면 Terraform은 아무런 변경사항을 만들지 않을겁니다만,<br>명령의 실행 결과에서 Consul 서버의 주소를 <code>consul_address</code> 이름의 출력값으로 확인할 수 있을 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-consul.png" alt="terraform apply 실행 후 확인할 수 있는 consul_address 출력" title="terraform apply 실행 후 확인할 수 있는 consul_address 출력">
<h4 id="다음-3"><a href="#다음-3" class="headerlink" title="다음"></a>다음</h4><blockquote>
<p>생성한 Consul 모듈은 이제 더이상 사용하지 않습니다. 필요치 않은 과금을 방지하려면 반드시 <code>terraform destroy</code> 명령을 통해 인프라를 제거하세요!</p>
</blockquote>
<p>어떤 <code>source</code> 종류들을 지원하는지, 어떻게 모듈을 작성하는지 등 모듈에 대한 자세한 정보를 얻기 원하신다면 <a href="https://www.terraform.io/docs/modules/" target="_blank" rel="external">모듈 문서</a>를 참고하세요.</p>
<h2 id="다음-단계들"><a href="#다음-단계들" class="headerlink" title="다음 단계들"></a>다음 단계들</h2><p>여러분들이 Terraform이 유용하다는 것을 알 수 있을뿐만 아니라, 여기서 배운 지식들로 여러분들의 인프라 구축을 향상시킬 수 있기를 바랍니다.</p>
<p>드디어 여러분들은 첫 걸음마를 뗐습니다.<br>더 많은 것들을 배우시고 싶은 분들을 위해 참고할만한 몇가지 링크를 남겨놓으니 참고하시기 바랍니다.</p>
<ul>
<li><a href="https://www.terraform.io/docs/" target="_blank" rel="external">Terraform 문서</a> - Terraform이 어떻게 동작하는지에 대한 기술 상세정보를 포함해 Terraform의 모든 기능들에 대한 자세한 레퍼런스가 담겨 있습니다.</li>
<li><a href="https://www.terraform.io/intro/examples/" target="_blank" rel="external">Terraform 예제</a> - Terraform을 사용하는 완벽한 기능의 구성 파일들이 담겨 있습니다. Terraform으로 어떤 것을 할 수 있는지 더 자세히 알아볼 수 있습니다.</li>
<li><a href="https://www.terraform.io/docs/import/" target="_blank" rel="external">Terraform 불러오기(Import)</a> - Import 문서는 기존 인프라를 Terraform으로 불러오기 위한 내용을 다룹니다.</li>
</ul>
<h2 id="회고"><a href="#회고" class="headerlink" title="회고"></a>회고</h2><p>처음에는 직접 가이드를 써보려고 했는데 생각보다 범위가 넓어 <a href="https://www.terraform.io/intro/getting-started/" target="_blank" rel="external">Terraform의 Getting Started 문서</a>를 한국어로 번역하는것을 기본으로 살을 좀 더 붙였습니다.<br>영어실력이 미천하여 다소 번역이 딱딱하거나 엉성할 수 있습니다 ㅠㅠ</p>
<p>사실 저는 DevOps 엔지니어가 아니라 풀스택 개발자입니다만, 최근에는 서비스를 배포하는 방법이 점점 다양하고 중요해지는 것 같아 DevOps를 열심히 공부하고 있습니다.<br>웹 생태계는 해가 지날수록 눈 깜짝하는 사이에 정말 많은것이 쏟아져나오고 빠르게 변화하고 있는데, DevOps 역시 정말 빠르게 변화하고 진화하는 것 같네요. 흥미진진합니다.</p>
<p><a href="https://www.hashicorp.com/#open-source-tools" target="_blank" rel="external">Hashicorp의 다른 제품들</a>, 그리고 <a href="https://www.terraform.io/intro/hashicorp-ecosystem.html" target="_blank" rel="external">그것들을 묶어서 만든 에코시스템</a>인 Atlas도 정말 대단합니다.<br><a href="https://www.hashicorp.com/devops.html" target="_blank" rel="external">Hashicorp - Devops Defined</a>를 보면 목표도 확실한 것 같고요.<br>예전에 Hashicorp의 대표인 <a href="https://github.com/mitchellh" target="_blank" rel="external">Mitchell Hashimoto</a>의 인터뷰 기사를 본 적이 있는데, DevOps를 바로잡기 위헤서 Terraform과 같은 도구들을 만들었다고 언급하기도 했죠.</p>
<p>오픈소스 프로젝트들에서 <code>vagrant up</code> 뿐만 아니라 <code>terraform apply</code>도 자주 마주칠 수 있기를 기대해봅니다!</p>
<h2 id="기념으로-남기는-링크"><a href="#기념으로-남기는-링크" class="headerlink" title="기념으로 남기는 링크"></a>기념으로 남기는 링크</h2><ul>
<li><a href="https://github.com/hashicorp/terraform/issues/10943" target="_blank" rel="external">Terraform issue #10943 - website: Broken markdown style on getting started page</a></li>
<li><a href="https://github.com/hashicorp/terraform/pull/10944" target="_blank" rel="external">Terraform PR #10944 - website: Fix broken markdown style on ‘lists’ section of variables page</a></li>
<li><a href="https://github.com/hashicorp/terraform/issues/10949" target="_blank" rel="external">Terraform issue #10949 - website: Incorrect description Variable page of Getting Started</a></li>
<li><a href="https://github.com/hashicorp/terraform/pull/10950" target="_blank" rel="external">Terraform PR #10950 - website: Correct unrelated contents on env vars in variables page</a></li>
<li><a href="https://github.com/hashicorp/consul/pull/2620" target="_blank" rel="external">Consul PR #2620 - Add Seoul region to the map for ubuntu</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2016/12/19/Terraform-101/terraform.png&quot; alt=&quot;Terraform&quot; title=&quot;Terraform&quot;&gt;
&lt;h1 id=&quot;Terraform&quot;&gt;&lt;a href=&quot;#Terraform&quot; class=&quot;headerl
    
    </summary>
    
      <category term="devops" scheme="https://mooyoul.github.io/categories/devops/"/>
    
    
      <category term="aws" scheme="https://mooyoul.github.io/tags/aws/"/>
    
      <category term="devops" scheme="https://mooyoul.github.io/tags/devops/"/>
    
      <category term="terraform" scheme="https://mooyoul.github.io/tags/terraform/"/>
    
      <category term="infrastructure" scheme="https://mooyoul.github.io/tags/infrastructure/"/>
    
      <category term="hashicorp" scheme="https://mooyoul.github.io/tags/hashicorp/"/>
    
  </entry>
  
  <entry>
    <title>귀뚜라미보일러 IoT 컨트롤러 설치기 및 뜯어보기</title>
    <link href="https://mooyoul.github.io/2016/11/06/installing-kiturami-iot-heating-controller/"/>
    <id>https://mooyoul.github.io/2016/11/06/installing-kiturami-iot-heating-controller/</id>
    <published>2016-11-06T00:37:39.000Z</published>
    <updated>2017-02-17T22:13:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="귀뚜라미보일러-IoT-온도-조절기"><a href="#귀뚜라미보일러-IoT-온도-조절기" class="headerlink" title="귀뚜라미보일러 IoT 온도 조절기"></a>귀뚜라미보일러 IoT 온도 조절기</h1><p>작년즈음 귀뚜라미보일러에서 Wi-Fi를 통해 스마트폰 제어가 가능한 온도 조절기를 발매했다는 소식을 들었습니다만,<br>아쉽게도 최신형 보일러에서만 사용할 수 있어 써볼 수가 없었습니다.</p>
<p>어느새 기억에서 잊혀져가고 있다가, 최근 <a href="http://clien.net/cs2/bbs/board.php?bo_table=use&amp;wr_id=943776&amp;sca=&amp;sfl=wr_subject&amp;stx=%EA%B7%80%EB%9A%9C%EB%9D%BC%EB%AF%B8" target="_blank" rel="external">클리앙의 한 사용기</a>를 보고 구형 보일러에서도 사용이 가능하다는 것을 알게 되었죠.</p>
<p>그런데 해당 사용기에서 MITM (Man in the middle, 중간자 공격)에 취약하다는 언급이 <a href="http://clien.net/cs2/bbs/board.php?bo_table=news&amp;wr_id=2266176&amp;sca=&amp;sfl=wr_subject&amp;stx=%EA%B7%80%EB%9A%9C%EB%9D%BC%EB%AF%B8" target="_blank" rel="external">클리앙 새로운 소식의 뉴스로 등장</a>하게 되면서, 유저들의 수 많은 질타를 받게 됩니다.</p>
<blockquote>
<p>현 시점에서는 <strong>안드로이드 사용자에 대해서만</strong> HTTPS를 사용하도록 API가 새로 만들어지고, App이 업데이트 되었습니다.</p>
</blockquote>
<p>Philips의 Hue, Xiaomi의 Home Gateway를 사용하고 있는 중인데, 국내 IoT 제품들의 완성도를 구경해보고도 싶고, 무엇보다 최근에 발견한 <a href="https://github.com/nfarina/homebridge" target="_blank" rel="external">Homebridge</a>라는 Node.js 기반 Homekit API 에뮬레이션 서버에 붙여보고 싶은 욕심이 들더라고요.</p>
<p>그래서.. 질렀고, 어제 수령해서 설치했습니다.</p>
<h2 id="개봉기"><a href="#개봉기" class="headerlink" title="개봉기"></a>개봉기</h2><img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06514.jpg" alt="패키지" title="패키지"> 
<p>패키지는 A4 크기의 소설책 한권 수준의 크기입니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06515.jpg" alt="패키지 옆면" title="패키지 옆면">
<p>보일러 및 온도 조절기에 따라 신형 (NCTR-10WIFI) / 순간식 (CTR-15WIFI) / 저탕식 (CTR-15WIFI) 로 구분됩니다.<br>CTR-15WIFI의 경우 순간식/저탕식 구분이 있습니다만, 기기 내 별도 설정 메뉴에 접근해서 변경이 가능합니다.</p>
<p>저는 순간식 모델입니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06522.jpg" alt="패키지 구성" title="패키지 구성">
<p>패키지 구성은 온도 조절기 본체, 백플레이트, 백플레이트 고정 나사, 설명서가 전부입니다.<br>저는 패키지에 포함된 백플레이트 고정 나사가 짧아서 기존 나사를 재활용했습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06523.jpg" alt="기존 온도 조절기가 설치되어 있는 모습" title="기존 온도 조절기가 설치되어 있는 모습">
<p>기존 온도 조절기가 설치되어 있는 모습니다. (좌하단)</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06523.jpg" alt="CTR-5700PLUS 조절기" title="CTR-5700PLUS 조절기">
<p>기존에 설치된 온도 조절기는 CTR-5700PLUS 모델인데, 이 모델은 보일러 모델에 따라 순간식/저탕식이 나뉩니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06526.jpg" alt="CTR-5700PLUS 조절기 후면" title="CTR-5700PLUS 조절기 후면">
<p>백플레이트는 기본적으로 장착된 상태인데, 탈거한 모습입니다. 캐패시터가 꽤 눈에띄네요.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06529.jpg" alt="CTR-15WIFI 옆면" title="CTR-15WIFI 옆면">
<p>옆을 보면 본체 하우징을 탈거할수 있는 홈이 보입니다.<br>탑 (액정측)하우징에는 걸쇠가, 바텀 하우징에는 홀이 있고 걸쇠가 홀에 걸치는 방식으로 본체 하우징이 고정되는 방식입니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06530.jpg" alt="CTR-15WIFI 기판" title="CTR-15WIFI 기판">
<p>궁금한걸 못참는 공돌이라 설치 전에 후다닥 뜯어봅니다.<br>역시나 캐패시터가 크고 아릅답..지는 않습니다. </p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06532.jpg" alt="CTR-15WIFI 기판 옆면" title="CTR-15WIFI 기판 옆면">
<p>궁금헸던 MCU와 Wi-FI 칩셋은 디스플레이 아래에 위치하고 있습니다.<br>아쉽게도 디스플레이 패널 상단이 납땜되어 있어 들어내서 확인할 수는 없었습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06533.jpg" alt="CTR-15WIFI 기판 상단부" title="CTR-15WIFI 기판 상단부">
<p>좌상단에 두번째 통신 채널 혹은 디버깅용 포트로 추정되는 홀이 보이네요. </p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06534.jpg" alt="CTR-15WIFI 기판 하단부" title="CTR-15WIFI 기판 하단부">
<p>역시나 캐패시터가 눈에 띕니다.<br>좌하단엔 온도 측정을 위해 사용되는 것으로 추정되는 서미스터 (thermistor)가 보입니다.</p>
<h2 id="설치기"><a href="#설치기" class="headerlink" title="설치기"></a>설치기</h2><img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06536.jpg" alt="전원 끄기" title="전원 끄기">
<p>안전을 위해 절연장갑을 착용하고, 기존에 사용중이던 온도 조절기는 전원버튼을 눌러서 끕니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06540.jpg" alt="온도조절기 탈거" title="온도조절기 탈거">
<p>온도조절기를 위쪽으로 밀어 백플레이트에서 본체를 탈거합니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06542.jpg" alt="탈거된 온도조절기" title="탈거된 온도조절기">
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06543.jpg" alt="탈거된 온도조절기 - 2" title="탈거된 온도조절기 - 2">
<p><strong>본체에 표시된 극성을 잘 메모해둡니다.</strong> (근데 저는 메모했는데도 실수했습니다 ㅋㅋㅋ)</p>
<p>신기하게도 두 온도조절기에 적혀있는 QA 담당자로 추정되는 분의 이름이 똑같습니다 ㅎㅎ</p>
<p>제 것은 얇은 단심으로 된 전선인데, 많이 꼬아진 상태로 스트레스를 많이 받았는지 살짝 움직이니 끊어져버렸습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06546.jpg" alt="온도 조절기에서 사용하는 두가닥의 전선" title="온도 조절기에서 사용하는 두가닥의 전선">
<p>나사를 풀어 기존 온도조절기에 고정된 전선을 빼냅니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06551.jpg" alt="기존 백플레이트와의 비교샷" title="기존 백플레이트와의 비교샷">
<p>새 온도조절기와 기존 온도조절기의 크기가 다르기 때문에 백플레이트도 교체해야합니다.<br>다행히 스크류 홀의 위치는 똑같아서 특별한 이슈 없이 교체할 수 있습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06553.jpg" alt="기존 백플레이트 탈거" title="기존 백플레이트 탈거">
<p>기존 백플레이트 탈거 후 새로운 백플레이트를 설치합니다.<br>(새 백플레이트 설치 사진은 깜빡하고 안찍었네요.. ㅠㅠ)</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06549.jpg" alt="와이어 스트리퍼로 피복 벗겨내기" title="와이어 스트리퍼로 피복 벗겨내기">
<p>새 온도조절기와 결선을 하기 전에, 기존 전선의 길이가 애매해서 정리하기로 합니다.<br>일단 여러 전선을 감싸고 있는 첫 피복을 와이어 스트리퍼로 벗겨냅니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06562.jpg" alt="전선 정리" title="전선 정리">
<p>두가닥 전선의 길이를 니퍼로 깔끔하게 맞춰줍니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06567.jpg" alt="와이어 스트리퍼로 피복 벗겨내기" title="와이어 스트리퍼로 피복 벗겨내기">
<p>각 전선은 연결을 위해 와이어 스트리퍼로 피복을 다시 벗겨냅니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06557.jpg" alt="접속부 쉽게 꺼내기" title="접속부 쉽게 꺼내기">
<p>드라이버를 사용하면 쉽게 빠지지 않는 접속부를 쉽게 꺼낼 수 있습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06569.jpg" alt="온도 조절기와 기존 전선 연결" title="온도 조절기와 기존 전선 연결">
<p>온도 조절기와 기존 전선을 연결합니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06571.jpg" alt="쨔잔" title="쨔잔">
<p>쨔잔! 연결 즉시 전원이 잘 들어오는걸 확인할 수 있습니다.<br>이 상태에서 전원버튼을 눌러서 잠시 꺼두고 (온도조절기가 실제로 꺼지는 건 아니였습니다..)</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06572.jpg" alt="합체" title="합체">
<p>백플레이트와 결합합니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06574.jpg" alt="끝" title="끝">
<p>설치가 잘 되었습니다.</p>
<p>(이때까지만 해도 연동에서 말썽을 일으킬 줄은 상상도 못했습니다….)</p>
<h2 id="연동기"><a href="#연동기" class="headerlink" title="연동기"></a>연동기</h2><p>연동을 위한 AP 모드 진입은 쉽습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06583.jpg" alt="AP모드 진입 방법" title="AP모드 진입 방법">
<p>전원을 끈 상태에서 예약설정/수온설정 버튼을 5초간 누르고 있으면…</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06587.jpg" alt="AP모드 진입중" title="AP모드 진입중">
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06588.jpg" alt="AP모드 진입중 - 2" title="AP모드 진입중 - 2">
<p>설정을 위한 AP 모드로 진입합니다. 현재 상태에서는 검색은 되나 접속이 되지 않습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06589.jpg" alt="AP모드 활성화" title="AP모드 활성화">
<p>30초정도 기다리면 AP모드 활성화를 의미하는 파란 안테나 아이콘이 LCD 우상단에 표시됩니다.<br>이 상태에서 앱에서 초기 연동 관련 설정을 진행하면 됩니다.</p>
<p>물론 호기심이 발동해 바로 연동 관련 설정을 진행하지 않았습니다 (…)</p>
<h3 id="호기심-발동"><a href="#호기심-발동" class="headerlink" title="호기심 발동"></a>호기심 발동</h3><p>일단 AP 모드에서 어떤 포트가 열려있는지 궁금했습니다.</p>
<p>설정을 위한 AP Mode라 하더라도 AP Mode는 이름 그대로 Access Point Mode이므로 Wi-Fi 되는 디바이스면 다 붙을수 있지요.<br>맥북으로 붙어봅니다.</p>
<p>DHCP로 192.168.200.2 ~ 192.168.200.254 대역을 할당해서 쓰네요.<br>게이트웨이는 192.168.200.1 이므로 192.168.200.1 호스트에 대해 스캔을 해보면…</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/well-known-ports.png" alt="스캔 결과" title="스캔 결과">
<p>80번이 열려있네요. 아마 시스템 관련 설정페이지겠지요.</p>
<p>curl으로 빠르게 훑어보면…</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/curl.png" alt="80번 포트의 컨텐츠" title="80번 포트의 컨텐츠">
<p>역시나 디바이스 관련 설정이 있습니다.<br>펌웨어 버전, MAC Address, 디바이스 재부팅 버튼, 펌웨어 업데이트 버튼이 보이네요.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/admin.png" alt="어드민 페이지" title="어드민 페이지">
<p>브라우저에서 보면 이렇습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/curl-head.png" alt="lwIP로 구현된 웹서버" title="lwIP로 구현된 웹서버">
<p>lwIP를 서버로 쓰고 있네요. <strong>lwIP는 BSD 라이선스인데 별도로 저작권자 표기를 발견하지는 못했습니다.</strong><br>아쉬운 부분입니다.</p>
<p>더 볼 것이 없어서 스킵을 하려고 하는데….</p>
<h2 id="문제-발생"><a href="#문제-발생" class="headerlink" title="문제 발생"></a>문제 발생</h2><img src="/2016/11/06/installing-kiturami-iot-heating-controller/ping.png" alt="다운" title="다운">
<p>호스트, 그러니까 온도 조절기가 먹통이 되는 사태가 발생했습니다. 다량의 패킷을 쏴서 그런지 먹통이 된 것 같네요.</p>
<p>전원버튼을 눌러서 전원을 끄고 다시 AP 모드에 진입을 수십번 반복했지만, 파란색 안테나 아이콘이 뜨지 않습니다.<br>AP 모드 진입 후 파란색 안테나 아이콘이 뜨기까지 십분 이상 기다렸는데도 활성화가 되지 않습니다 -_-;;</p>
<p>아무리 생각해봐도 기기에 붙어있는 ‘전원 버튼’ 은 실제로 온도 제어기의 전원을 제어하는 것은 아닌 것 같아서,<br>리셋 버튼이나 리셋 핀을 찾아보았습니다만 그 어디에도 없었습니다.</p>
<p>이 상황에서 확실히 온도 제어기를 껐다가 다시 켜는 방법은 연결된 보일러를 끄는 것이라 유일하다고 판단을 했는데…<br>장식장 뒤편에 보일러실이 있어서 보일러 전원 코드를 뽑을수도 없는 상황이었습니다.</p>
<p>백플레이트 뜯어내서 연결된 전선을 끊고 다시 연결할까 생각해봤지만…<br>귀찮아서 결국 보일러랑 연결된 차단기를 찾아서 차단기를 내렸다가 다시 올렸습니다.</p>
<p>그랬더니 예상대로 AP모드가 잘 활성화가 되었습니다. </p>
<p>근데 이번에는 아이폰에서 공유기 연결을 위한 초기 설정이 안됩니다.<br>iPhone 6 Plus / iOS 10.0.2 를 사용하고 있는데, 아이폰에서 AP모드를 붙고 나서 설정을 시도하면 또 먹통이 됩니다… -_-;;;;</p>
<p>차단기 내리고 다시 설정… 을 몇번 반복하다가 그냥 노는 안드로이드 단말 찾아서 설정하니 한방에 붙네요.</p>
<p>허탈했습니다….</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06591.jpg" alt="정상적으로 붙은 상태" title="정상적으로 붙은 상태">
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06592.jpg" alt="정상적으로 붙은 상태" title="정상적으로 붙은 상태">
<p>공유기에 정상적으로 붙으면 이렇게 PASS 텍스트가 찍힙니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06593.jpg" alt="연동 완료" title="연동 완료">
<p>회원가입후 기기 등록까지 완료되면 최종적으로 이런 화면이 표시됩니다.</p>
<h2 id="패킷-훔쳐보기"><a href="#패킷-훔쳐보기" class="headerlink" title="패킷 훔쳐보기"></a>패킷 훔쳐보기</h2><p>개인적으로 insecure/suspicious 하다고 판단되는 장비들은 별도의 Bridged AP로 고립시키고,<br>필요시 tcpdump를 통해 언제든지 패킷스니핑이 가능하도록 내부망을 운용하고 있습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/infra.png" alt="Internal wireless infrastructure" title="Internal wireless infrastructure">
<p>대강 요런 모습입니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/DSC06576.jpg" alt="산딸기" title="산딸기">
<p>저렇게 Raspberry pi (무려 1세대 Model B 모델!)에 iptime N300UA를 붙여서 Soft AP를 만든것이죠.</p>
<p>App에서 오고 가는 HTTP/HTTPS 패킷들은 주로 Charles Proxy를 통해 쉽고 간편하게 훔쳐볼 수 있고,<br>breakpoint를 걸어 request/response를 마음대로 제어할 수 있기 때문에 앱에서 사용하는 HTTP/HTTPS<br>기반 API를 뜯어보기에 좋습니다.</p>
<p>AP 모드에서 초기 연동 설정을 하기 이전에<br>tcpdump over ssh + wireshark 조합으로 온도 조절기에서 오고 가는 패킷들을 캡쳐하고,<br>Chalres Proxy를 통해 App에서 오고 가는 패킷들을 캡쳐하도록 설정했습니다.</p>
<h3 id="온도-제어기-서버간-패킷-훔쳐보기"><a href="#온도-제어기-서버간-패킷-훔쳐보기" class="headerlink" title="온도 제어기 - 서버간 패킷 훔쳐보기"></a>온도 제어기 - 서버간 패킷 훔쳐보기</h3><img src="/2016/11/06/installing-kiturami-iot-heating-controller/packet-1.png" alt="초기 연결 이후 패킷 흐름" title="초기 연결 이후 패킷 흐름">
<p>(공유기 연결 이전에 캡쳐를 시작했기 때문에, DHCP로 IP를 받아오고, ARP 응답을 하는 것이 보입니다.)</p>
<p>초기 공유기와 연결이 되면, TCP를 통해 서버에 기기 등록 관련 메세지를 즉시 보냅니다. 재미있는 점은, 별도로 DNS 질의를 하지 않는다는 것입니다.<br>즉, 도메인이 아닌 IP가 펌웨어에 하드코딩 되어 있습니다. 물론 IP가 변경될 일은 없겠지만요.<br>Round-robin DNS로 load balancing을 할 수도 있을거란 생각을 해보지만, 사용자가 소규모라 따로 분산처리가 필요치 않다고 판단했겠지요. (Xiaomi의 경우에는 Round robin DNS를 위해 A 레코드에 18개 호스트가 등록되어 있습니다)</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/packet-2.png" alt="TCP 데이터 패킷 흐름" title="TCP 데이터 패킷 흐름">
<p>온도 제어기와 서버간 TCP 패킷은 암호화 되어있지 않습니다.</p>
<p>(다시 Xiaomi와 비교해보자면, Xiaomi는 Message Header는 암호화 되어 있지 않지만, message body는 AES-128-CBC로 암호화되어 오고갑니다.)</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/packet-3.png" alt="인터넷 상태 확인을 위한 DNS Query" title="인터넷 상태 확인을 위한 DNS Query">
<p>또 재미있는것은, <strong>인터넷 연결 상태를 확인하기 위해 2분마다 google.com 의 A 레코드를 조회하는 DNS Query를 보낸다</strong>는 것입니다.</p>
<p>어쩄거나 패킷이 암호화 되어 있지 않은 상태이기 때문에, 패킷의 구조나 명령 종류에 대해서는 패킷을 분석해보면 쉽게 알아낼 수 있을것입니다.</p>
<p><strong>다르게 생각해보자면, 내부망에 침입이 가능한 경우 API를 통해서가 아니라 직접 디바이스로 명령 패킷을 보낼 수도 있다는 것이겠지요 :)</strong></p>
<p>패킷 수준의 분석은 일단 충분한 정보를 얻었다고 판단해 여기까지 진행하고, HTTP(S) API를 살펴보기로 합니다.</p>
<h3 id="애플리케이션-서버간-HTTP-S-요청-응답-훔쳐보기"><a href="#애플리케이션-서버간-HTTP-S-요청-응답-훔쳐보기" class="headerlink" title="애플리케이션 - 서버간 HTTP(S) 요청/응답 훔쳐보기"></a>애플리케이션 - 서버간 HTTP(S) 요청/응답 훔쳐보기</h3><p>애플리케이션 - 서버간 사용하는 API는 크게 두가지로 나뉩니다.</p>
<p>첫번째는, iOS App과 구버전 Android App에서 사용하는 HTTP API<br>두번째는, 업데이트된 최신 Android App에서 사용하는 HTTPS API<br>가 있습니다.</p>
<h4 id="업데이트된-안드로이드-앱-HTTPS-API-뜯어보기"><a href="#업데이트된-안드로이드-앱-HTTPS-API-뜯어보기" class="headerlink" title="업데이트된 안드로이드 앱 - HTTPS API 뜯어보기"></a>업데이트된 안드로이드 앱 - HTTPS API 뜯어보기</h4><p>위에서 초기 연동에 문제가 있어서 안드로이드 앱을 사용했기 때문에,<br>안드로이드에서 사용하는 <em>업데이트된</em> HTTPS API를 살펴보겠습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/https-1.png" alt="HTTPS Request Overview" title="HTTPS Request Overview">
<p>Charles Proxy로 가로챈 Request입니다. HTTPS Protocol을 확인할 수 있습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/poodle.png" alt="SSLv3 protocol 사용 가능" title="SSLv3 protocol 사용 가능">
<p>HTTP에서 HTTPS로 변경은 되었으나, POODLE Attack 위험이 있는 SSLv3을 지원하고 있습니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/missing-hsts.png" alt="Missing HSTS Header" title="Missing HSTS Header">
<p>또한, HSTS 헤더가 존재하지 않기 때문에 별도의 루트 인증서 설치 없이도 SSL MITM이 쉽게 가능합니다.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/https-2.png" alt="여전히 존재하는 일부 HTTP API" title="여전히 존재하는 일부 HTTP API">
<p>회원가입에서 사용하는 주소검색 API는 여전히 HTTP를 사용합니다.<br>이와 별개로, 우편번호 검색 API에서 질의가 exact match이기 때문에 질의에 공백이 들어가면 검색 결과가 나타나지 않고,<br>건물명이 포함된 우편번호를 검색하는 경우, 일부만 입력하면 검색결과가 나타나지 않아 불편합니다.</p>
<blockquote>
<p>예: <code>귀뚜라미빌딩</code> 으로 등록된 우편번호 검색시 <code>귀뚜라미</code> 만 입력하는 경우 검색 불가</p>
</blockquote>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/https-3.png" alt="아이디와 비밀번호가 세번 날아간다!" title="아이디와 비밀번호가 세번 날아간다!">
<p>좀 아쉬운건, 아이디/비밀번호를 보내는 의미를 알 수 없는 분리된 API 3개가 존재한다는 것입니다.</p>
<p>위 이미지는 회원가입 이후 로그인시 날아가는 요청들인데, 각 역할은 다음과 같습니다. </p>
<ol>
<li>회원가입 요청 / 단순 성공여부 응답</li>
<li>API Access Key 생성 / 생성된 API Key 응답: UUID 형태이고, <strong>본 Access Key는 첫 발급시 Cookie처럼 동작합니다 (!!!)</strong></li>
<li>로그인 요청 (2. 에서 얻은 Token을 HTTP Header로 실어서 인증 성공시 해당 Access Token에 권한 부여, 이후에는 Access Key 발급 없고 Login API의 Response body의 JSON payload내 key field로 제공됨)</li>
</ol>
<p>개인적으로는 1~3을 굳이 분리할 필요가 있나 생각이 듭니다. 단일 API로 통일해도 충분했을 것 같은데 말이죠 :)<br>인증 매커니즘은 많이 아쉬운 부분입니다. 이건 그냥 Cookie 대신 Custom HTTP Header를 통해 세션키를 쓰겠다는 것과 다름없어 보이는데요.</p>
<img src="/2016/11/06/installing-kiturami-iot-heating-controller/https-4.png" alt="명령 패킷" title="명령 패킷">
<p>디바이스로 보낼 명령은 단일 API를 사용하는 것 같습니다.<br>실내온도 21도로 설정했을때의 요청입니다.</p>
<p>JSON payload 내 <code>message</code> field에 직접 Packet payload (in hex string) 를 실어 보내네요.<br>어디서 본 것 같다고 생각했는데 바로 위 TCP Packet Payload에서 봤던 그것이었습니다.</p>
<p>HTTPS 요청과 응답 역시 시간을 들여 분석해보면 더 자세한 것을 알 수 있을것입니다.<br>그래도 HTTP 대비 나아진 부분이 보이네요. 더이상 Response payload에 password가 포함되어 있지 않습니다.</p>
<h4 id="iOS-앱-HTTP-API-뜯어보기"><a href="#iOS-앱-HTTP-API-뜯어보기" class="headerlink" title="iOS 앱 - HTTP API 뜯어보기"></a>iOS 앱 - HTTP API 뜯어보기</h4><p>iOS 앱에서 사용하는 HTTP API를 위와 같은 방법으로 살펴보았으나, </p>
<ol>
<li>도메인이 아닌 특정 IP로 접속을 요청하는 점</li>
<li>API Protocol이 HTTPS가 아닌 HTTP인 점</li>
</ol>
<p>이외에는 큰 차이가 없어 자세히 기술하지는 않습니다.</p>
<h2 id="다음-할일"><a href="#다음-할일" class="headerlink" title="다음 할일"></a>다음 할일</h2><p>어느정도 내부를 뜯어보았으니, 이 다음은 Homebridge plugin을 만들어 Homekit에 붙여볼 차례입니다.</p>
<p>이 부분은 진행인 작업이고, 완료되면 별도 포스트로 찾아뵙도록 하겠습니다!</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;귀뚜라미보일러-IoT-온도-조절기&quot;&gt;&lt;a href=&quot;#귀뚜라미보일러-IoT-온도-조절기&quot; class=&quot;headerlink&quot; title=&quot;귀뚜라미보일러 IoT 온도 조절기&quot;&gt;&lt;/a&gt;귀뚜라미보일러 IoT 온도 조절기&lt;/h1&gt;&lt;p&gt;작년즈음 귀
    
    </summary>
    
      <category term="gadget" scheme="https://mooyoul.github.io/categories/gadget/"/>
    
    
      <category term="iot" scheme="https://mooyoul.github.io/tags/iot/"/>
    
      <category term="thermometer" scheme="https://mooyoul.github.io/tags/thermometer/"/>
    
      <category term="kiturami" scheme="https://mooyoul.github.io/tags/kiturami/"/>
    
      <category term="research" scheme="https://mooyoul.github.io/tags/research/"/>
    
      <category term="network" scheme="https://mooyoul.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>집의 조명 시스템을 Hue로 전환하다 - 1편</title>
    <link href="https://mooyoul.github.io/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/"/>
    <id>https://mooyoul.github.io/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/</id>
    <published>2016-09-04T22:59:14.000Z</published>
    <updated>2017-02-17T22:13:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Philips-Hue"><a href="#Philips-Hue" class="headerlink" title="Philips Hue"></a>Philips Hue</h4><p>Philips Hue는 <strong>Personal wireless lighting</strong>, 개인 무선 조명을 슬로건으로 가지는 Philips의 조명 제품군입니다.<br>일반적인 LED 조명들과 동일하게 저전력 고효율의 성능을 가지고 있고, 밝기를 조정하는 디밍 (Dimming)이 가능할 뿐만 아니라 원하는 색상을 색상 피커 (Color picker)에서 찍어 표현할 수도 있습니다.<br>무엇보다 전구별로 각각 다른 색과 밝기를 조합해 장면 (Scene)을 만들어내 특유의 무드를 연출하기 좋죠.</p>
<p>램프들은 지그비(Zigbee)라는 2.4Ghz대역을 사용하는 무선 통신을 통해 브릿지와 연결되고, 앱과 Siri를 통해 제어가 가능합니다.<br>Zigbee를 사용하기 때문에 Bluetooth로 페어링되는 다른 조명들과 달리 커버리지가 훨씬 넓고 복수의 조명을 동시 제어(그룹 제어)할 수 있으며, 집 밖에서도 제어가 가능합니다.<br><a href="http://www.developers.meethue.com/" target="_blank" rel="external">공개 API</a>가 있어 서드파티 애플리케이션을 만들수도 있고요.</p>
<p>자세한 내용은 아래 링크와 비디오를 참고해보세요.</p>
<div class="video-container"><iframe src="//www.youtube.com/embed/lCv4r3wgsPQ" frameborder="0" allowfullscreen></iframe></div>
<div class="video-container"><iframe src="//www.youtube.com/embed/griC5Tu0R2A" frameborder="0" allowfullscreen></iframe></div>
<ul>
<li><a href="http://www2.meethue.com/en-us/" target="_blank" rel="external">Hue 공식 소개 페이지 - Meet Hue (영문/미국)</a></li>
<li><a href="http://www2.meethue.com/ko-kr/" target="_blank" rel="external">Hue 공식 소개 페이지 - Meet Hue (한글/대한민국)</a> - <em>일부 제품군이 제외되어 있습니다</em></li>
</ul>
<h4 id="지르고보자"><a href="#지르고보자" class="headerlink" title="지르고보자"></a>지르고보자</h4><p>올해 7월, <a href="http://slickdeals.net/f/8918479-philips-hue-led-white-and-color-ambiance-starter-kit-multicolor-125-free-shipping" target="_blank" rel="external">Slickdeals를 둘러보던 중 Bestbuy via eBay에서 2세대 Hue white and color ambiance starter kit을 $119에 판매한다는 쓰레드</a>를 보자마자 싸다는 이유로 무작정 스타터 킷을 주문했습니다.<br><img src="/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/starter-kit-order-details.png" alt="싸..싸다!" title="싸..싸다!"></p>
<p>1세대도 아닌 2세대 스타터킷이 $199에 주로 판매되는걸 생각한다면 엄청난 딜이었죠.</p>
<img src="/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/must-buy.jpg" alt="출처: https://namu.wiki/w/%ED%8C%8C%EC%9D%BC:attachment/1000685049.jpg" title="출처: https://namu.wiki/w/%ED%8C%8C%EC%9D%BC:attachment/1000685049.jpg"> 
<p>이미 1세대 스타터킷을 구매해 사용하고 있었지만 2세대는 아래와 같은 변경사항이 있어서 더더욱 유혹을 뿌리칠 수 없었습니다.<br>그래서 일단 질렀습니다.</p>
<h5 id="2세대-Hue는-무엇이-바뀌었나"><a href="#2세대-Hue는-무엇이-바뀌었나" class="headerlink" title="2세대 Hue는 무엇이 바뀌었나?"></a>2세대 Hue는 무엇이 바뀌었나?</h5><p>2세대 Hue 제품군은 크게 다음과 같은 변화가 있었습니다:</p>
<blockquote>
<p>2세대 브릿지는 Apple의 Homekit을 지원 (Homekit 인증을 위해 하드웨어 일부 변경), 이 덕에 Siri를 통해 음성 제어가 가능<br>2세대 White and color ambiance bulb는 밝기가 1세대에 비해 더 밝아짐<br>Lightstrip은 Lightstrip Plus라는 이름으로 변경되고 밝기가 밝아졌으며, 여러개의 스트립을 연결하여 길이 연장이 가능<br>거치형인 Iris가 단종되고 이를 대체하는 Bloom 출시. Iris 대비 크기가 작아짐<br>이동 거치가 가능한 충전식 조명 Hue Go 출시<br>Hue White 및 White ambiance bulb 출시</p>
</blockquote>
<h5 id="미국에서-구매한-Hue-한국에서-사용할-수-있을까"><a href="#미국에서-구매한-Hue-한국에서-사용할-수-있을까" class="headerlink" title="미국에서 구매한 Hue, 한국에서 사용할 수 있을까?"></a>미국에서 구매한 Hue, 한국에서 사용할 수 있을까?</h5><p>막상 지르고 나서 정신을 차려보니 전압이 호환되는지 확인을 안해봐서 걱정이 되었습니다.<br>싸다고 일단 질렀는데, 전압이 안맞으면 낭패니까요…</p>
<p>브릿지부터 찾아봅니다. 1세대처럼 DC 어댑터를 쓸테고, 요즘에 나오는 DC 어댑터들은 대개 프리볼트지만…<br>혹시 모르니까 <a href="http://www2.meethue.com/en-us/productdetail/philips-hue-bridge" target="_blank" rel="external">미국 Hue 홈페이지의 Hue Bridge 페이지</a>에서 찾아봅니다.</p>
<img src="/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/bridge-spec.png" alt="Specifications of Hue Bridge" title="Specifications of Hue Bridge">
<p>오, 역시 프리볼트를 지원합니다!<br>게다가 5V 2A 입력이라 PoE Splitter를 통해 전원을 공급해도 되고,<br>어댑터 잭(꼬다리)를 잘라내 USB로 개조한다면 멀티포트 USB 충전기에 꽂아 콘센트 공간을 줄일수도 있습니다.</p>
<p>다음, <a href="http://www2.meethue.com/en-us/productdetail/philips-hue-white-and-color-ambiance---extension-bulbs" target="_blank" rel="external">White and color ambiance bulb</a>을 봅니다.</p>
<img src="/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/bulb-spec.png" alt="Specifications of Hue White and color ambiance bulb (2nd gen)" title="Specifications of Hue White and color ambiance bulb (2nd gen)">
<p>으..음…?!?!?!?!???!?!?!!!<br>아닐거야.. 부정하며 아마존의 Product Q&amp;A를 찾아봅니다…</p>
<img src="/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/amazon-qna.png" alt="No. Only 120v..." title="No. Only 120v...">
<p>오.. 마이… 갓….  </p>
<img src="/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/goja.gif" alt="출처: https://namu.wiki/w/%ED%8C%8C%EC%9D%BC:%EA%B3%A0%EC%9E%90%EB%9D%BC%EB%8B%88.gif" title="출처: https://namu.wiki/w/%ED%8C%8C%EC%9D%BC:%EA%B3%A0%EC%9E%90%EB%9D%BC%EB%8B%88.gif">
<p>사실을 받아들이기 싫어서… 어떻게 정확한 정보를 알 수 없을까? 고민하다가<br>미국에 판매되는 전기제품들은 FCC 인증을 받는다는 것을 떠올리고 FCC ID로 데이터를 찾아봅니다.<br>그리고… <a href="https://apps.fcc.gov/oetcf/eas/reports/ViewExhibitReport.cfm?mode=Sum&amp;calledFromFrame=N&amp;RequestTimeout=500&amp;application_id=KCWgrlBX4C%2F7LuE4veHPag%3D%3D&amp;fcc_id=O3M9290011419X" target="_blank" rel="external">발견한 정확한 FCC 인증정보</a>! 넘나 다행인것…</p>
<img src="/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/fcc-bulb.png" alt="FCC Exhibit Report of O3M9290011419X - Hue White and color ambiance bulb (2nd gen)" title="FCC Exhibit Report of O3M9290011419X - Hue White and color ambiance bulb (2nd gen)">
<p>저기 보이세요? ACDC board 120V230V!!!!<br>어깨너머 하드웨어를 배운 저는 저게 <em>(특수문자가 짤려서)</em> <strong>AC/DC board 120V~230V</strong>. 교류 120v~230v 입력을 받는 AC to DC 회로, 그러니까 프리볼트를 의미한다는것을 곧바로 알아챘습니다.<br>그리고 뒤늦게 <a href="https://www.quora.com/Will-Philips-Hue-work-with-220v" target="_blank" rel="external">Quora에 올라온 Will Philips Hue work with 220v?</a>도 발견했죠…</p>
<p>요악하자면, <strong>Hue White ambiance bulb/Hue White bulb를 제외한 대부분의 제품군들은 220v에서도 사용이 가능</strong>합니다.</p>
<p>지금 이 포스트를 쓰고 있는 시점에도 Hue Bridge (2nd gen), Hue Lightstrip Plus, Hue White and color ambiance bulb (2nd gen), Hue Iris를 돼지코만 끼워서 잘 사용하고 있습니다.</p>
<h4 id="2세대-스타터킷-수령-및-설치"><a href="#2세대-스타터킷-수령-및-설치" class="headerlink" title="2세대 스타터킷 수령 및 설치"></a>2세대 스타터킷 수령 및 설치</h4><p>2세대 스타터킷을 수령해 기존 1세대 브릿지와 램프를 교체하고 나니 집의 조명 시스템을 모두 Hue로 변경하면 좋겠단 생각이 들었습니다.<br><del>인간의 욕심은 끝이 없다 (…)</del></p>
<h4 id="첫번째-추가-램프-구입-Lightstrip-Plus-Iris"><a href="#첫번째-추가-램프-구입-Lightstrip-Plus-Iris" class="headerlink" title="첫번째 추가 램프 구입 - Lightstrip Plus, Iris"></a>첫번째 추가 램프 구입 - Lightstrip Plus, Iris</h4><img src="/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/iris-order-details.png" alt="Lightstip Plus / Iris order details" title="Lightstip Plus / Iris order details">
<p><del>기프트카드 털어내기</del></p>
<p>첫번째로 추가 구매한 램프는 Hue Lightstrip Plus와 Hue Iris입니다.<br>Hue Iris는 벽을 향해 조명을 쏴서 간접 조명으로 사용하고, Lightstrip Plus 또한 천장에 설치된 천장등의 외곽을 따라 간접 조명으로 사용해보고 싶었습니다.<br>무엇보다 천장등에 설치된 FL 형광등 전체를 Lightstrip Plus를 조각내 만든 LED Bar로 교체하기 위해서는 사전 테스트가 필요하기도 했고요.</p>
<p>그리고 수령샷.</p>
<img src="/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/IMG_2811.jpg" alt="Package of Hue Lightstrip Plus / Hue Iris" title="Package of Hue Lightstrip Plus / Hue Iris">
<p>Lightstrip Plus를 열어보면 이렇게 생겼습니다.</p>
<img src="/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/20160903_010727.jpg" alt="Package of Hue Lightstrip Plus" title="Package of Hue Lightstrip Plus">
<p>Iris는 허겁지겁 박스를 뜯고 테스트를 하느라 따로 개봉샷을 찍어둔게 없어 실 사용샷으로 대체합니다.<br>설치는 그냥 콘센트에 꽂고 앱에서 초기 페어링만하는게 전부라 따로 설명할 내용이 없네요;;</p>
<img src="/2016/09/05/Migrating-home-lighting-system-to-Philips-Hue/20160907_051539.jpg" alt="Hue Iris was installed behind TV" title="Hue Iris was installed behind TV">
<h4 id="Lightstrip-Plus를-천장-간접조명으로-설치"><a href="#Lightstrip-Plus를-천장-간접조명으로-설치" class="headerlink" title="Lightstrip Plus를 천장 간접조명으로 설치"></a>Lightstrip Plus를 천장 간접조명으로 설치</h4><p>기존 거실등은 2개의 전원이 내려오고, 각 전원은 2개의 EL 램프가 연결되어 총 4개의 램프로 구성되어 있었습니다.</p>
<p>이 중, 한 전원에 연결된</p>
<p>기본적으로 미국에서 구입한 Hue Lightstrip은 11자 110v US 플러그를 사용하기 때문에  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Philips-Hue&quot;&gt;&lt;a href=&quot;#Philips-Hue&quot; class=&quot;headerlink&quot; title=&quot;Philips Hue&quot;&gt;&lt;/a&gt;Philips Hue&lt;/h4&gt;&lt;p&gt;Philips Hue는 &lt;strong&gt;Personal wire
    
    </summary>
    
      <category term="gadget" scheme="https://mooyoul.github.io/categories/gadget/"/>
    
    
      <category term="draft" scheme="https://mooyoul.github.io/tags/draft/"/>
    
      <category term="iot" scheme="https://mooyoul.github.io/tags/iot/"/>
    
      <category term="hue" scheme="https://mooyoul.github.io/tags/hue/"/>
    
      <category term="diy" scheme="https://mooyoul.github.io/tags/diy/"/>
    
  </entry>
  
</feed>
