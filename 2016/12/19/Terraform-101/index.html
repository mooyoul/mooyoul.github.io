<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>Terraform 101 | init 1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="TerraformTerraform은 Infrastructure as code를 모토로 하는 Hashicorp의 오픈소스 도구입니다.
인프라 구성을 코드를 통해 효과적이고 안전하게 만들고, 변경하고, 버저닝할 수 있습니다.
SVN, Git과 같은 버전 제어 시스템과 함께 사용한다면 다른 사람과 함께 구성을 변경할 수 있으며,변경 이력을 투명하게 살펴볼 수">
<meta property="og:type" content="article">
<meta property="og:title" content="Terraform 101">
<meta property="og:url" content="https://mooyoul.github.io/2016/12/19/Terraform-101/index.html">
<meta property="og:site_name" content="init 1">
<meta property="og:description" content="TerraformTerraform은 Infrastructure as code를 모토로 하는 Hashicorp의 오픈소스 도구입니다.
인프라 구성을 코드를 통해 효과적이고 안전하게 만들고, 변경하고, 버저닝할 수 있습니다.
SVN, Git과 같은 버전 제어 시스템과 함께 사용한다면 다른 사람과 함께 구성을 변경할 수 있으며,변경 이력을 투명하게 살펴볼 수">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/hello-terraform.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-plan.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-apply.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/ec2-dashboard-after-apply.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-show.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-plan-after-modification.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-apply-after-modification.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/ec2-dashboard-after-modification-apply.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-plan-destroy.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-destroy-confirmation.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-destroy.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-plan-with-dependency.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-apply-with-dependency.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-graph.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-graph-graphviz.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-graph-with-non-dependent-resource.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-graph-graphviz-with-non-dependent-resource.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-destroy-for-review-pararrel.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-plan-for-review-pararrel.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-apply-for-review-pararrel.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-apply-with-provisoner.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-provisoner-local-exec-result.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-plan-asking-variable.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-plan-asking-variable.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-map.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-apply-with-output-variables.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-output.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-get.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-plan-module-depth.png">
<meta property="og:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform-consul.png">
<meta property="og:updated_time" content="2016-12-30T23:18:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Terraform 101">
<meta name="twitter:description" content="TerraformTerraform은 Infrastructure as code를 모토로 하는 Hashicorp의 오픈소스 도구입니다.
인프라 구성을 코드를 통해 효과적이고 안전하게 만들고, 변경하고, 버저닝할 수 있습니다.
SVN, Git과 같은 버전 제어 시스템과 함께 사용한다면 다른 사람과 함께 구성을 변경할 수 있으며,변경 이력을 투명하게 살펴볼 수">
<meta name="twitter:image" content="https://mooyoul.github.io/2016/12/19/Terraform-101/terraform.png">
  
    <link rel="alternate" href="/atom.xml" title="init 1" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/typing.css">
</head>

  
    <body>
  
      <div id="container" class="container">
        <article id="post-Terraform-101" class="article article-type-post" itemscope itemprop="blogPost">
  <header id="header" class="header">
  <nav id="main-nav" class="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/atom.xml">RSS</a>
    
      <a class="main-nav-link" href="https://github.com/mooyoul">Github</a>
    
      <a class="main-nav-link" href="https://www.linkedin.com/in/mooyoul">LinkedIn</a>
    
  </nav>
  <nav id="sub-nav">
    
      <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
    
  </nav>
</header>

  <hr/>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Terraform 101
    </h1>
  

      </header>
    
    <div class="article-entry typo" itemprop="articleBody">
      
        <img src="/2016/12/19/Terraform-101/terraform.png" alt="Terraform" title="Terraform">
<h1 id="Terraform"><a href="#Terraform" class="headerlink" title="Terraform"></a>Terraform</h1><p>Terraform은 <strong>Infrastructure as code</strong>를 모토로 하는 <a href="https://www.hashicorp.com/" target="_blank" rel="external">Hashicorp</a>의 오픈소스 도구입니다.</p>
<p>인프라 구성을 코드를 통해 효과적이고 안전하게 만들고, 변경하고, 버저닝할 수 있습니다.</p>
<p>SVN, Git과 같은 버전 제어 시스템과 함께 사용한다면 다른 사람과 함께 구성을 변경할 수 있으며,<br>변경 이력을 투명하게 살펴볼 수 있고, 코드로 작성되므로 자동화가 가능합니다.</p>
<h2 id="코드로-표현된-인프라"><a href="#코드로-표현된-인프라" class="headerlink" title="코드로 표현된 인프라"></a>코드로 표현된 인프라</h2><p>다음은 Terraform 공식 홈페이지에서 소개하고 있는 한 예제입니다.<br>예제를 살펴보면 코드로 인프라를 표현한다는 것이 무엇을 의미하는지 바로 알 수 있습니다.</p>
<script src="https://gist.github.com/mooyoul/5f0221b2b5cf637834e4685f71f24b1f.js"></script>

<p>위 Terraform 코드는 인프라 내에 두개의 리소스를 정의합니다.</p>
<p>하나는 DigitalOcean의 Droplet을 정의하는 리소스이고,<br>다른 하나는 DNSimple의 레코드를 정의하는 리소스입니다.</p>
<p>여기서 DNSimple의 레코드를 정의한 리소스를 보면 흥미로운 부분이 있는데,<br><strong>위 DigitalOcean Droplet의 Public IP를 참조하고 있다</strong>는 것입니다.</p>
<p>즉, 다른 리소스의 정보를 참조하여 정말 유연하게 인프라를 구성할 수 있죠!</p>
<h2 id="비슷한-소프트웨어와-무엇이-다른가"><a href="#비슷한-소프트웨어와-무엇이-다른가" class="headerlink" title="비슷한 소프트웨어와 무엇이 다른가?"></a>비슷한 소프트웨어와 무엇이 다른가?</h2><p>AWS의 CloudFormation, Heat은 코드로 인프라를 구성한다는 점에서 Terraform과 비슷하지만,<br>다음과 같은 차이가 있습니다.</p>
<ol>
<li>Terraform은 다양한 Vendor를 지원하므로, 유연한 인프라 구성이 가능하다.<ul>
<li>e.g.) DNS 서비스는 DNSimple을 사용하고, CDN은 Akamai로 구성</li>
</ul>
</li>
<li>오픈소스 생태계<ul>
<li>공통된 Terraform 설정은 모듈로 패키징되어 재사용할 수 있다.</li>
</ul>
</li>
<li>적용 전 변경사항 미리보기 가능 (Plan)<ul>
<li>Terraform은 계획과 적용 단계가 분리되어 있어 변경사항 적용 전 무엇이 변경되는지 검토가 가능</li>
</ul>
</li>
<li>리소스간 의존성을 그래프로 확인할 수 있음 (Graph)<ul>
<li>dot-formatted 이므로 <a href="http://www.graphviz.org/" target="_blank" rel="external">Graphviz</a>로 의존성 그래프를 시각화 할수도 있음</li>
</ul>
</li>
</ol>
<p>Terraform은 실행 계획이 캡쳐되면, 실행 단계는 캡쳐된 실행 계획에서 필요로 하는 부분만 반영하도록 제한합니다.</p>
<p>다른 도구들은 계획과 실행 단계가 분리되어 있지 않고 합쳐져있어 오퍼레이터들이 인프라 구성 변경으로 무엇이 변경되는지 추론하도록 강요받지만,<br>Terraform은 변경사항 적용 이전에 무슨 일이 벌어지는지 정확하게 알 수 있게 제공함으로써, 오퍼레이터들이 변경사항을 적용하는 것을 신뢰할 수 있게 합니다.</p>
<h2 id="Terraform-설치"><a href="#Terraform-설치" class="headerlink" title="Terraform 설치"></a>Terraform 설치</h2><p>Terraform은 단일 실행파일로 배포되고 있으며, 이 덕분에 설치가 아주 간단합니다.</p>
<p><a href="https://www.terraform.io/downloads.html" target="_blank" rel="external">공식 홈페이지의 Downloads 페이지</a>에서 Terraform을 얻을 수 있습니다.</p>
<p>이 글을 작성하는 시점에서는 0.8.1 버전이 최신 버전이고, macOS 기준 Terraform을 설치하는 방법은 다음과 같습니다:</p>
<blockquote>
<p>$ # echo $PATH 를 통해 실행 경로를 미리 확인하세요.<br>$ # 저는 /usr/local/bin 을 즐겨쓰기에 해당 경로를 기준으로 했습니다.<br>$ wget <a href="https://releases.hashicorp.com/terraform/0.8.1/terraform_0.8.1_darwin_amd64.zip" target="_blank" rel="external">https://releases.hashicorp.com/terraform/0.8.1/terraform_0.8.1_darwin_amd64.zip</a><br>$ unzip terraform_0.8.1_darwin_amd64.zip<br>$ cp terraform /usr/local/bin/ # root 권한이 필요한 경우 sudo를 사용해야 할 수 있습니다.</p>
</blockquote>
<p>참 쉽죠?!</p>
<p>설치를 확인하려면 터미널에서 terraform을 그냥 실행해보면 됩니다.</p>
<blockquote>
<p>$ terraform</p>
</blockquote>
<img src="/2016/12/19/Terraform-101/hello-terraform.png" alt="Hello, Terraform!" title="Hello, Terraform!">
<h2 id="Terraform으로-인프라-만들기"><a href="#Terraform으로-인프라-만들기" class="headerlink" title="Terraform으로 인프라 만들기"></a>Terraform으로 인프라 만들기</h2><p>Terraform을 설치했으니, Terraform으로 새로운 인프라를 구성해보겠습니다.<br>이 섹션에서는 몇가지 AWS 서비스들을 Terraform으로 구성하는 방법을 소개하므로,<br>미리 IAM 에서 Access Key를 발급받아 두시길 바랍니다!</p>
<h4 id="첫-Terraform-설정-파일-만들기"><a href="#첫-Terraform-설정-파일-만들기" class="headerlink" title="첫 Terraform 설정 파일 만들기"></a>첫 Terraform 설정 파일 만들기</h4><p>우리는 이번 섹션에서 새로운 EC2 인스턴스를 만들기 위해 새로운 Terraform 설정 파일을 만들어보겠습니다.</p>
<p>Terraform 설정 파일은 <a href="https://github.com/hashicorp/hcl" target="_blank" rel="external">Hashicorp Configuration Language (HCL)</a> 이라는 문법을 사용하고, <code>.tf</code> 확장자를 사용합니다.<br>HCL은 JSON과 완벽히 호환되고, Terraform 설정 파일은 JSON으로도 작성하여 사용할 수 있습니다 (이 경우에는 <code>.tf.json</code> 을 사용합니다.)</p>
<p>Terraform 설정 파일에 대한 자세한 내용은 <a href="https://www.terraform.io/docs/configuration/" target="_blank" rel="external">이곳</a>을 참고하시고,<br>일단 새로운 Terraform 설정 파일을 만들어보겠습니다. </p>
<p>먼저, <code>terraform-101</code> 이라는 디렉토리를 새로 만든 후, 해당 디렉토리에 아래 내용을 <code>example.tf</code>으로 저장하세요.<br>(기본적으로 Terraform은 working directory의 모든 <code>.tf</code> 파일을 불러오기 때문에, 만일을 대비해 새로운 디렉터리를 만드는 것입니다.)</p>
<p>지금은 AWS의 Access Key와 Secret Key를 직접 기입했지만,<br>나중에는 변수에서 두 값을 추출해서 사용하는 방법을 알아볼 것이니 하드코딩된 값을 너무 신경쓰진 마세요!</p>
<script src="https://gist.github.com/mooyoul/d707c4cad5354d5c8e5bf9b79dc6c12d.js"></script>

<p>위 설정은 바로 적용해 볼 수 있는 (완전한) 예제입니다.</p>
<p>기본적인 구조를 설명하면 다음과 같습니다:</p>
<p><code>provider</code> block은 알려진 Provider를 구성하기 위해 사용됩니다.<br>위 예제에서는 EC2 리소스를 정의하기 위해 <code>&quot;aws&quot;</code>를 사용했습니다.<br>Provider는 리소스를 생성하고 관리하는 책임 (역할)을 가집니다.<br>여러 서비스를 관리하기 위해 복수의 Provider를 정의할 수도 있습니다 (e.g. Akamai + AWS + DNSimple)</p>
<p><code>resource</code> block은 인프라 내에 존재하는 리소스를 정의하기 위해 사용됩니다.<br>하나의 리소스는 EC2 인스턴스나 Heroku 애플리케이션과 같은 물리적인 컴포넌트를 의미합니다.</p>
<p>Resource block은 block이 시작되기 전 두개의 문자열을 가지고 있습니다.<br>바로 <strong>리소스의 타입</strong>과 <strong>리소스의 이름</strong>입니다.<br>위 예제를 기준으로 하면 <code>aws_instance</code>가 리소스의 타입이고, <code>example</code>이 리소스의 이름이 됩니다.</p>
<p>Terraform에서는 리소스의 타입에 붙은 접두사(Prefix)를 통해 Provider에 매핑합니다.<br><code>aws_instance</code>의 경우, 접두사는 <code>aws</code>이고, 이는 <code>aws</code> provider에 의해 관리되는 리소스임을 의미합니다.</p>
<p>Resource block 안에는 해당 리소스와 관련한 속성들이 들어갑니다.<br>위 예제의 경우 Ubuntu 16.04 LTS AMI를 사용하고, <code>t2.micro</code> 인스턴스를 정의했습니다.</p>
<h4 id="실행-계획-Execution-Plan"><a href="#실행-계획-Execution-Plan" class="headerlink" title="실행 계획 (Execution Plan)"></a>실행 계획 (Execution Plan)</h4><p>이제 Terraform이 위 환경을 적용할 때 무엇을 할지 살펴보기로 합니다.</p>
<p>위 <code>example.tf</code> 가 있는 디렉토리에서 <code>terraform plan</code> 명령을 실행해보세요.</p>
<p>아래와 비슷한 내용이 출력될 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-plan.png" alt="terraform plan" title="terraform plan">
<p><code>terraform plan</code> 명령은 현재 환경에서 Terraform이 어떠한 변경사항을 만들어내는지 보여줍니다.<br>출력 내용은 Git과 비슷한 형식으로 어떤 항목들이 변경되는지 알려줍니다.</p>
<p>위의 경우 <code>aws_instance.example</code> 리소스가 새롭게 생성될 것이고,<br>총 1개의 생성 / 0개의 수정 / 0개의 삭제가 발생한다는 것을 알 수 있죠.</p>
<p><code>&lt;computed&gt;</code> 라고 표기된 값은 리소스가 생성되기 전까지는 알 수 없습니다.<br>당연하겠지만 (?) EC2 인스턴스를 생성하기 전에 미리 Private IP를 알아낼 수는 없으니까요.<br>그렇지만, Terraform에서는 인프라를 구성할 때 다른 리소스에서 <code>&lt;computed&gt;</code>로 표기된 해당 속성의 값을 참조할 수 있습니다. (이따 자세히 알아보겠습니다!)</p>
<h4 id="적용-Apply"><a href="#적용-Apply" class="headerlink" title="적용 (Apply)"></a>적용 (Apply)</h4><p>위 <code>terraform plan</code> 명령으로 확인한 변경사항이 적절하다고 판단되면, 이제 실제로 리소스를 만들 시간입니다. (위 예제에서 EC2 인스턴스를 만드니까요)</p>
<p>적용은 <code>terraform apply</code> 명령을 사용하면 됩니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-apply.png" alt="terraform apply" title="terraform apply">
<p>와우! 인스턴스를 새롭게 만들고, 해당 인스턴스가 준비될 때 까지 기다리는걸 확인할 수 있습니다!</p>
<p>EC2 대시보드에서 확인해보니, 정말 잘 만들어졌네요.</p>
<img src="/2016/12/19/Terraform-101/ec2-dashboard-after-apply.png" alt="생성된 인스턴스를 EC2 Dashboard에서도 확인할 수 있습니다." title="생성된 인스턴스를 EC2 Dashboard에서도 확인할 수 있습니다.">
<p>또한 기본적으로 Terraform은 몇몇 상태 정보를 <code>terraform.tfstate</code> 파일에 저장합니다.</p>
<p>이 상태 파일은 아주 중요한데, Terraform이 무엇을 관리하고 있는지 알 수 있도록 여러 리소스의 메타데이터를 실제 리소스 ID로 매핑한 정보를 담고 있기 때문입니다.<br>그리고 이 상태 파일은 Terraform을 사용하려는 유저가 있다면 (e.g. 다른 팀원), 반드시 환경설정 파일과 함께 저장되어야하고 함께 배포되어야만 합니다.<br>다만 이 상태 파일에는 잠재적인 비밀 정보를 포함할 수 있으므로, Terraform에서는 원격에서 상태를 저장할 수 있도록 설정을 구성하는 것을 권장하고 있습니다.</p>
<p>원격 상태 관리에 대해서는 다음 링크에서 자세히 살펴보시기 바랍니다:<br><a href="https://www.terraform.io/docs/state/remote/index.html" target="_blank" rel="external">https://www.terraform.io/docs/state/remote/index.html</a></p>
<p>현재 인프라 구성 상태를 확인하고 싶은 경우, <code>terraform show</code> 명령을 사용하면 됩니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-show.png" alt="terraform show" title="terraform show">
<p>아까 Plan / Apply 명령을 내렸을 때와는 다르게, 생성한 리소스에 대해 자세한 정보를 얻을 수 있는 것을 확인하실 수 있습니다.</p>
<h2 id="Terraform-으로-인프라-변경하기"><a href="#Terraform-으로-인프라-변경하기" class="headerlink" title="Terraform 으로 인프라 변경하기"></a>Terraform 으로 인프라 변경하기</h2><p>우리는 방금 전 Terraform으로 하나의 EC2 인스턴스를 생성하는 첫 인프라를 만들었습니다.<br>이번에는 Terraform으로 위 인스턴스를 변경해보도록 하겠습니다.<br>Terraform이 어떻게 변경사항을 다루는지 보세요!</p>
<p>Terraform으로 인프라를 변경할 때, Terraform은 변경될 상태에 필요한 부분만 변경하는 실행 계획을 만듭니다.</p>
<h4 id="설정-변경"><a href="#설정-변경" class="headerlink" title="설정 변경"></a>설정 변경</h4><p>방금 만든 EC2 인스턴스는 Ubuntu 16.04 LTS AMI를 사용하고 있는데,<br>이를 Amazon Linux AMI로 변경해보도록 하겠습니다.</p>
<p>설정을 변경하는 방법은 아주 간단합니다.<br>우리는 AMI 이미지를 교체하려고 하므로, resource 블럭 내의 <code>ami</code> 속성의 값을 <code>ami-983ce8f6</code> 으로 변경하기만 하면 됩니다.</p>
<script src="https://gist.github.com/mooyoul/04b2d34fe1c5e873f7bda89facc9bd89.js"></script>

<p>요렇게요.</p>
<p>변경사항을 반영하는것은 이전 단계에서 배웠습니다.<br><code>terraform plan</code> 으로 실행 계획을 체크하고, 문제가 없다면 <code>terraform apply</code> 으로 반영하면 됩니다.</p>
<h4 id="설정-변경-후의-실행-계획-Execution-Plan"><a href="#설정-변경-후의-실행-계획-Execution-Plan" class="headerlink" title="설정 변경 후의 실행 계획 (Execution Plan)"></a>설정 변경 후의 실행 계획 (Execution Plan)</h4><p>설정을 변경하고 나서 <code>terraform plan</code> 명령을 실행하면 다음과 같은 화면이 나올 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-after-modification.png" alt="설정 변경 후 terraform plan" title="설정 변경 후 terraform plan">
<p>변경사항 앞에 붙은 <code>-/+</code> 접두사는 Terraform이 해당 리소스를 제거하고 재생성한다는 의미입니다.<br>반대로, 변경하는 일부 속성이 리소스의 제거 없이 즉시 업데이트가 가능한 경우 Terraform은 <code>~</code> 접두사로 변경사항을 표시하게 됩니다.<br>(<code>~</code> 접두사가 붙은 것은 차차 확인하기로 하고, 일단 넘어갑시다!)</p>
<p>EC2 인스턴스의 AMI를 변경하는 것은 새 인스턴스를 생성하는 것을 요구하기 때문에, 기존 리소스를 제거하고 새롭게 생성해야하죠. </p>
<p>Terraform은 우리를 위해 이러한 디테일도 잘 다루어줍니다. (세심해라…)</p>
<p>그래서 실행 계획 (Execution Plan) 에서 Terraform이 무엇을 할지 명확하게 알 수 있죠.</p>
<p>덧붙여서, 실행 계획의 결과를 보면 AMI에 대한 변경사항이 리소스를 삭제하고 재생성하도록 요구했다는 것을 알아챌 수 있습니다.<br>이 정보를 적절히 사용한다면, 특정 시점에 리소스를 제거하거나 생성하는 업데이트를 피하기 위해 변경사항을 조절할 수도 있습니다.<br>(e.g. 일단 리소스 재생성 없이 즉시 적용할 수 있는 변경사항부터 적용하고, 리소스 재생성을 요구하는 변경사항은 나중에 적용하기)</p>
<h4 id="설정-변경-후-적용-Apply"><a href="#설정-변경-후-적용-Apply" class="headerlink" title="설정 변경 후 적용 (Apply)"></a>설정 변경 후 적용 (Apply)</h4><p>이전 실행 계획 섹션에서 우리는 무엇이 변경될 지 알아냈습니다. 그럼 이번엔 적용해보죠.</p>
<p>이전과 동일하게 <code>terraform apply</code> 를 통해 변경사항을 적용하면 됩니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-apply-after-modification.png" alt="설정 변경 후 terraform apply" title="설정 변경 후 terraform apply">
<p>실행 계획에서 예측한 대로, 기존 인스턴스를 제거하고, 새 인스턴스를 생성하는 것을 확인할 수 있습니다.</p>
<img src="/2016/12/19/Terraform-101/ec2-dashboard-after-modification-apply.png" alt="설정 변경 후 EC2 Dashboard" title="설정 변경 후 EC2 Dashboard">
<p>EC2 대시보드에서 확인해보면, 인스턴스를 제거하고 새롭게 생성한 것을 확인할 수 있습니다.<br>Amazon Linux AMI로 바뀐 것이 보입니다!</p>
<p><code>terraform show</code>를 통해 새로운 인스턴스의 속성들을 확인할 수도 있습니다.</p>
<p>여러분들은 Terraform과 함께 인프라를 변경하는 것이 얼마나 쉬운지 보았습니다.<br>다음 섹션에서는 우리가 만든 인프라를 통째로 제거해 보겠습니다.</p>
<h2 id="Terraform으로-인프라-제거하기"><a href="#Terraform으로-인프라-제거하기" class="headerlink" title="Terraform으로 인프라 제거하기"></a>Terraform으로 인프라 제거하기</h2><p>우리는 Terraform으로 인프라를 어떻게 생성하고 변경하는지 알아봤습니다.<br>이번 섹션에서는 여러개의 리소스들을 생성하고 의존성을 표시하는지 알아보기 전에,<br>Terraform으로 관리하는 인프라를 <strong>완전히</strong> 제거하는 방법을 알아보도록 하겠습니다.<br>그러니까, <strong>인프라 내에 포함된 모든 리소스들을 제거하는 방법</strong>이겠죠.</p>
<p>여러분들의 인프라를 제거한다는 것은 프로덕션 환경에서 아주 드문 일입니다만,<br>여러분들이 만약 Terraform을 개발, 테스트, QA 환경과 같은 (자주 바뀌는) 인프라를 구성하기 위해 사용한다면,<br>(모든 리소스를 삭제하기 위해) 인프라를 제거하는 기능을 유용하게 사용할 수도 있을 것입니다.</p>
<h4 id="인프라-제거시-실행-계획-Execution-Plan"><a href="#인프라-제거시-실행-계획-Execution-Plan" class="headerlink" title="인프라 제거시 실행 계획 (Execution Plan)"></a>인프라 제거시 실행 계획 (Execution Plan)</h4><p>우리의 인프라를 제거하기 전에, 우리는 <code>terraform plan -destroy</code> 명령을 통해 어떤 리소스들이 제거되는지 미리 확인할 수 있습니다.<br><code>-destroy</code> 플래그를 사용하는 경우, 우리는 Terraform에게 인프라를 제거하는 실행 계획을 묻게 됩니다.<br>인프라를 제거한다는 것은, Terraform이 관리하는 모든 리소스를 제거한다는 것을 의미합니다.</p>
<p>여러분들은 이 명령의 결과로 Terraform이 어떤 어떤 리소스들을 관리하고 있고 제거하는지 검증할 수 있습니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-destroy.png" alt="terraform plan -destroy" title="terraform plan -destroy">
<p>현재는 구성해둔 리소스가 AWS의 EC2 인스턴스 하나이므로 해당 인스턴스 하나만 표시가 됩니다.</p>
<h4 id="제거"><a href="#제거" class="headerlink" title="제거"></a>제거</h4><p>변경사항 적용과 달리 인프라를 제거하는 작업은 <code>apply</code> 명령이 아닌 <code>destroy</code> 명령을 사용합니다.<br><code>terraform destroy</code> 명령을 통해 한번 인프라를 제거해보도록 하겠습니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-destroy-confirmation.png" alt="terraform destroy confirmation" title="terraform destroy confirmation">
<p>당연하겠지만, 정말 인프라를 제거할 것인지 확인하는 절차가 있습니다.<br>여기서 <code>Ctrl + C</code>로 인터럽트를 하거나, <code>yes</code> 이외의 응답을 하면 인프라 제거를 취소할 수 있습니다.<br>Terraform은 안전을 위한 매커니즘으로 오직 <code>yes</code> 만 올바른 응답으로 취급합니다.</p>
<p>지금은 연습이기 때문에 마음 편하게 <code>yes</code>를 입력할 수 있지만,<br><strong>인프라를 제거하는 작업은 취소할 수 없으므로 항상 주의</strong>해야합니다.</p>
<p><code>yes</code> 를 입력하고 <code>Enter</code> 키를 눌러 응답하면 실제로 인프라가 제거되는 것을 확인할 수 있습니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-destroy.png" alt="terraform destroy" title="terraform destroy">
<p>덧붙여서, <code>terraform apply</code> 명령처럼, Terraform은 어떤 순서로 항목을 제거할지 결정할정도로 똑똑합니다.<br>이번 예제에서는 오직 한 리소스만 존재하기 때문에 순서를 지정해 리소스를 제거할 필요는 없지만,<br>여러 리소스가 존재하는 복잡한 케이스의 경우라면 Terraform은 올바른 순서로 리소스를 제거 할 것입니다.</p>
<p>여러분들은 로컬 머신에서 Terraform을 통해 인프라를 만들고, 수정하고, 제거하는 방법을 배웠습니다.</p>
<p>Terraform의 강력함은 간편한 관리도 있지만, 리소스간 의존성을 둘 수 있는 점 또한 큰 장점입니다.</p>
<p>다음 섹션에서는 Terraform에서 리소스 간 의존성을 정의하는 방법을 알아보도록 하겠습니다.</p>
<h2 id="리소스-의존성-Resource-Dependency"><a href="#리소스-의존성-Resource-Dependency" class="headerlink" title="리소스 의존성 (Resource Dependency)"></a>리소스 의존성 (Resource Dependency)</h2><p>이번 섹션에서 우리는 리소스 의존성을 알아볼 것입니다.<br>여러분들은 여러복수의 리소스를 정의하는것을 보실 수 있을 뿐만 아니라,<br>다른 리소스의 정보를 참조하도록 리소스 파라미터를 사용하는 것을 확인할 수 있습니다.</p>
<p>지금까지는 우리는 오직 한 리소스만 포함하는 인프라를 구성했었습니다.<br>하지만 실제 인프라는 다양한 리소스와 여러 리소스 종류를 가지고 있습니다.<br>Terraform 설정은 여러 리소스들과 리소스 종류를 포함할 수 있고, 이러한 리소스 종류들은 여러 Provider를 통해 더 늘릴 수 있습니다.</p>
<p>이번 섹션에서는 우리는 여러 리소스를 다루는 예제와 함께,<br>어떻게 리소스가 특정 리소스의 속성을 참조해 해당 리소스를 구성할 수 있는지 알아보겠습니다.</p>
<h4 id="Elastic-IP-할당하기"><a href="#Elastic-IP-할당하기" class="headerlink" title="Elastic IP 할당하기"></a>Elastic IP 할당하기</h4><p>기존에 관리하던 EC2 인스턴스에 Elastic IP를 할당해 기존 설정을 개선해보도록 하겠습니다.<br>여러분들의 기존 <code>example.tf</code> 환경설정 파일에 다음 항목을 추가하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">resource &quot;aws_eip&quot; &quot;ip&quot; &#123;</div><div class="line">    instance = &quot;$&#123;aws_instance.example.id&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/171468de36b2d462e1a4e955eb0cc690.js"></script>

<p>위 스니펫에서 정의한 리소스는 <code>aws_eip</code> 리소스 타입을 정의하는 것만 제외하면 이전에 EC2 인스턴스 리소스를 추가할 때와 많이 비슷할 것입니다.</p>
<p><code>aws_eip</code> 리소스 종류는 Elastic IP를 할당하고, 해당 Elastic IP를 EC2 인스턴스에 연동합니다.<br><code>aws_eip</code> 리소스 종류는 정의된 단 하나의 파라미터인 <code>instance</code> 속성이 있는데, 해당 속성에 지정된 인스턴스에 해당 Elastic IP를 연동하게 됩니다.<br>이번에 해당 <code>instance</code> 속성에 설정하는 값은 일종의 템플릿 표기법(interpolation)을 이용하여,<br>우리가 이전에 관리하던 EC2 인스턴스의 속성 값을 참조할 수 있도록 합니다.</p>
<p>템플릿 표기법(interpolation)은 간단합니다.<br>위 예제에서는 <code>aws_instance.example</code> 리소스의 <code>id</code> 속성을 참조하라는 의미입니다.</p>
<h4 id="계획과-실행-Plan-amp-Execute"><a href="#계획과-실행-Plan-amp-Execute" class="headerlink" title="계획과 실행 (Plan &amp; Execute)"></a>계획과 실행 (Plan &amp; Execute)</h4><p>실행 플랜을 보기 위해 <code>terraform plan</code> 명령을 실행해보세요.<br>아마 다음과 같은 출력이 나올 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-with-dependency.png" alt="terraform plan (with resource dependency)" title="terraform plan (with resource dependency)">
<p>테라폼은 EC2 인스턴스 하나와 Elastic IP 하나, 총 두개의 리소스를 만들 것입니다.<br>여기서 <code>aws_eip</code> 의 <code>instance</code> 속성 값이 아직 템플릿 표기법(interpolation) 으로 표시되는데,<br>이는 해당 변수 (variable)는 <code>aws_instance</code> 가 생성될 때 까지는 알 수 없기 때문입니다.</p>
<p>이 이유로, 해당 값은 적용 시점 (apply-time)에서 되기 떄문에 <code>terraform apply</code> 명령의 결과로만 확인할 수 있습니다.</p>
<p>그렇다면, 얼른 확인해보도록 하죠.</p>
<p><code>terraform apply</code> 명령을 실행해 현재 구성을 적용합니다.</p>
<p>이번에는 다음과 같은 결과가 나올 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-apply-with-dependency.png" alt="terraform apply (with resource dependency)" title="terraform apply (with resource dependency)">
<p>여기서 Terraform이 실제로 동작하는 것을 볼 수 있는데,<br>Terraform이 Elastic IP를 할당받기 이전에 (Elastic IP 리소스를 생성하기 이전에) EC2 인스턴스를 먼저 생성하는것을 볼 수 있습니다.</p>
<p>이전에 Elastic IP의 <code>instance</code> 속성의 값을 EC2 인스턴스의 ID를 참조하는 템플릿 표기법(interpolation)으로 기입했기 때문에,<br>Terraform은 의존성을 추론할 수 있고, 인스턴스를 먼저 만들어야 함을 알 수 있습니다.</p>
<h4 id="암시적인-의존성과-명시적인-의존성-Implicit-and-Explicit-Dependencies"><a href="#암시적인-의존성과-명시적인-의존성-Implicit-and-Explicit-Dependencies" class="headerlink" title="암시적인 의존성과 명시적인 의존성 (Implicit and Explicit Dependencies)"></a>암시적인 의존성과 명시적인 의존성 (Implicit and Explicit Dependencies)</h4><p>Terraform에서 대부분의 의존성들은 암시적입니다. Terraform은 리소스간의 속성 참조를 기반으로 의존성을 추론하기 때문입니다.</p>
<p>Terraform은 의존성 정보를 통해 리소스들의 관계를 그래프로 그리고,<br>어떤 순서로 리소스들을 생성할 지 결정할 뿐만 아니라, 어떤 리소스들이 병렬로 동시에 생성될 수 있을지 추론합니다.<br>위의 예제에서는, Elastic IP가 EC2 인스턴스에 의존적이므로 그 두개의 리소스는 병렬로 (동시에) 생성될 수 없었습니다.</p>
<p>암시적인 의존성은 잘 동작하고 대개 여러분들이 원하는 것이긴 하지만,<br>여러분들은 모든 리소스에서 사용 가능한 <code>depends_on</code> 속성을 통해 명시적인 의존성을 정의할 수 있습니다.</p>
<p>이번에는 이전 예제와 동일하게 동작하고 불필요하긴 속성이긴 하지만<br><code>aws_eip</code> 리소스에 <code>depends_on</code> 속성을 정의해 명시적인 의존성을 정의해보도록 하겠습니다.</p>
<p>아래와 같이 <code>depends_on</code> 속성을 기입하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">resource &quot;aws_eip&quot; &quot;ip&quot; &#123;</div><div class="line">    instance = &quot;$&#123;aws_instance.example.id&#125;&quot;</div><div class="line">    depends_on = [&quot;aws_instance.example&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/8b898db453731fdf86dc28895c28e4a0.js"></script>

<p>만약 여러분이 Terraform이 생성하는 의존성 구조 (dependency chain)에 대해 확신하지 못했다면,<br>이번 기회에 <code>terraform graph</code> 명령을 사용해 그래프를 확인해보세요.<br><code>terraform graph</code> 명령의 출력 결과는 <a href="http://www.graphviz.org/" target="_blank" rel="external">Graphviz</a>로도 확인할 수 있는 dot 형식 (dot-formatted) 입니다.</p>
<p><code>terraform graph</code> 명령을 실행하면 다음과 같은 결과가 나올 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-graph.png" alt="terraform graph" title="terraform graph">
<p>위 이미지에서 하이라이트한 라인을 보면, <code>aws_eip.ip</code> 리소스가 <code>aws_instance.example</code> 리소스에 의존성을 가지고 있음을 확인할 수 있습니다.</p>
<p>Graphviz를 통해 시각화 한 그래프를 확인해보면 의존성을 더욱 확실히 알 수 있습니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-graph-graphviz.png" alt="Graphviz로 시각화 한 terraform graph" title="Graphviz로 시각화 한 terraform graph">
<p><code>terraform graph</code> 명령에 대해 더 자세히 알기 원하신다면,<br><a href="https://www.terraform.io/docs/commands/graph.html" target="_blank" rel="external">Terraform 공식 문서</a>를 참고해보세요.</p>
<h4 id="의존성이-없는-리소스-Non-Dependent-Resources"><a href="#의존성이-없는-리소스-Non-Dependent-Resources" class="headerlink" title="의존성이 없는 리소스 (Non-Dependent Resources)"></a>의존성이 없는 리소스 (Non-Dependent Resources)</h4><p>우리는 이제 다른 EC2 인스턴스를 구성해 인프라를 늘릴 수도 있습니다.</p>
<p>다른 리소스에 대해 의존성이 없다면, 해당 리소스는 병렬로 (동시에) 생성될 수 있음을 뜻하기도 합니다.</p>
<p>이번에는 Ubuntu 16.04 AMI를 사용하는 <code>another</code> 라는 이름을 가진 새로운 EC2 인스턴스 리소스를 정의해보겠습니다.</p>
<p>기존 환경설정 파일에 다음 리소스를 추가하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">resource &quot;aws_instance&quot; &quot;another&quot; &#123;</div><div class="line">  ami           = &quot;ami-f293459c&quot;</div><div class="line">  instance_type = &quot;t2.micro&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/15c78a2a3098fc67274a226ae8150666.js"></script>

<p><code>terraform graph</code> 명령을 실행해보면 다음과 같이 <code>aws_intance.another</code> 리소스에는 아무런 의존성이 없고,<br>이는 병렬로 (동시에) 생성될 수 있을 것 같이 보입니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-graph-with-non-dependent-resource.png" alt="terraform graph (with non-dependent resource)" title="terraform graph (with non-dependent resource)">
<p>이번 그래프 역시 Graphviz로 시각화 해보면 다음과 같을 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-graph-graphviz-with-non-dependent-resource.png" alt="Graphviz로 시각화 한 terraform graph" title="Graphviz로 시각화 한 terraform graph">
<p>더욱 눈에 잘 들어오죠?</p>
<p>자, 이번에는 <code>terraform destroy</code> 명령으로 인프라를 제거합시다. (네, 모든 리소스를 삭제할겁니다!)<br>왜냐하면 인프라를 제거하고 <code>terraform apply</code> 명령을 통해 새롭게 인프라를 생성할때, 병렬로 EC2 인스턴스가 생성되는 것을 보려고 하거든요!</p>
<p>아까 배운대로 <code>terraform plan -destroy</code> 명령으로 인프라 제거시 발생하는 변경사항을 검토하고,<br><code>terraform destroy</code> 명령을 통해 인프라를 제거합니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-destroy-for-review-pararrel.png" alt="인프라를 제거하고!" title="인프라를 제거하고!">
<p>그 다음 <code>terraform plan</code> 명령으로 새롭게 생성할 인프라를 검토해보고,</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-for-review-pararrel.png" alt="새롭게 만드는 인프라 검토하고!" title="새롭게 만드는 인프라 검토하고!">
<p>마지막으로 <code>terraform apply</code> 명령을 통해 병렬로 (동시에) EC2 리소스가 생성되는지 확인해봅니다!</p>
<img src="/2016/12/19/Terraform-101/terraform-apply-for-review-pararrel.png" alt="동시에 EC2 인스턴스 생성" title="동시에 EC2 인스턴스 생성">
<p>우와!!! <code>terraform apply</code> 명령을 실행하는 동안, Terraform이 정말 병렬로 EC2 인스턴스를 생성하는것을 확인할 수 있습니다!</p>
<p>어때요? 멋지죠!?</p>
<h4 id="다음-섹션으로-넘어가기-전에…"><a href="#다음-섹션으로-넘어가기-전에…" class="headerlink" title="다음 섹션으로 넘어가기 전에…"></a>다음 섹션으로 넘어가기 전에…</h4><p>다음 섹션으로 넘어가기 전에 Terraform 환경설정 파일에서 방금 만들었던 <code>another</code> EC2 인스턴스 리소스를 제거하고 <code>terraform destroy</code> 명령을 다시 실행해 인프라를 제거하세요.<br>왜냐하면 이제 <code>another</code> 리소스를 쓸 일이 없고, 다음 장에서 소개하는 프로비저닝은 인스턴스가 생성되는 시점에만 동작하기 때문입니다.</p>
<p>여기까지 따라오시는 동안 인프라를 만들고 삭제하는건 많이 해보셨을 것이기 때문에, 이번에는 따로 스크린샷을 첨부하진 않습니다.<br>(사실 귀찮아서… ㅠㅠ)<br>이번에 <code>terraform destroy</code> 명령을 실행할 때에는 <code>terraform apply</code> 명령을 실행했을 때와는 반대로 Elastic IP가 먼저 삭제되는 것을 확인하실 수 있으실 겁니다 :)</p>
<p>이번 섹션에서는 복수 리소스를 정의하는 것과 함께 기본적인 리소스 의존성, 그리고 템플릿(interpolation)을 통한 속성 참조를 소개했습니다.<br>다음 섹션에서는, Provision을 사용해 우리가 실행한 인스턴스에 기본적인 bootstrapping을 수행하는 방법을 알아보도록 하겠습니다.</p>
<h2 id="프로비저닝-Provision"><a href="#프로비저닝-Provision" class="headerlink" title="프로비저닝 (Provision)"></a>프로비저닝 (Provision)</h2><p>여기까지 오신 여러분들은 인프라를 생성하고 수정하는건 이제 꽤 익숙해졌을겁니다.<br>이번에는 프로비저너(Provisioner)들을 사용하여 인스턴스들이 생성된 후 어떻게 해당 인스턴스들을 초기화 (initialize) 할 수 있는지에 대해 알아볼 것입니다.</p>
<p>만약 여러분들이 이미지 기반의 인프라 (아마 <a href="https://www.packer.io/" target="_blank" rel="external">Packer</a>로 생성한 이미지)를 이미 사용하고 있다면,<br>지금까지 알아본 내용으로도 충분할 것입니다. </p>
<p>하지만 인스턴스들에 초기 설정 (initial setup)을 하기 원한다면, 프로비저너(Provisioner)를 사용해 파일을 업로드하고, 쉘 스크립트를 실행하고, 설정 관리을 위한 소프트웨어 같은 것들을 설치하고 실행하도록 여러분을 도울 것입니다.</p>
<h4 id="프로비저너-정의하기-Defining-a-Provisioner"><a href="#프로비저너-정의하기-Defining-a-Provisioner" class="headerlink" title="프로비저너 정의하기 (Defining a Provisioner)"></a>프로비저너 정의하기 (Defining a Provisioner)</h4><p>프로비저너 (Provisioner)를 정의하기 위해서는,<br>이전에 설정한 Terraform 설정 파일에서 <code>example</code> EC2 인스턴스의 리소스를 다음처럼 변경하면 됩니다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</div><div class="line">  ami           = &quot;ami-983ce8f6&quot;</div><div class="line">  instance_type = &quot;t2.micro&quot;</div><div class="line"></div><div class="line">  provisioner &quot;local-exec&quot; &#123;</div><div class="line">    command = &quot;echo $&#123;aws_instance.example.public_ip&#125; &gt; ip_address.txt&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/12fa08f71c06078eb6ccbeae300ef90f.js"></script>

<p>여러분들은 리소스 블럭 내부에 프로비저너(Provisioner) 블럭이 새롭게 추가된 것을 확인하실 수 있을겁니다.<br>이전 섹션에서 여러 리소스를 정의해서 사용할 수 있었던 것 처럼, 프로비저너(Provisioner) 역시 복수개를 정의하여 여러 단계의 프로비저닝 과정을 구성할 수 있습니다.</p>
<p>Terraform은 <a href="https://www.terraform.io/docs/provisioners/" target="_blank" rel="external">여러 종류의 프로비저너(Provisioner)를 지원</a>하지만,<br>일단 이번 예제에서는 <code>local-exec</code> 프로비저너(Provisioner)만을 사용해보도록 하겠습니다.</p>
<p>이 <code>local-exec</code> 프로비저너(Provisioner)는 다른 프로비저너들과는 다르게 인스턴스 접속에 필요한 정보들 (e.g. SSH Key, Username, Password)에 대해 신경쓰지 않아도 되거든요.</p>
<p><code>local-exec</code> 프로비저너(Provisioner)는 The local-exec provisioner Teraform을 실행하고 있는 로컬 머신에서 명령을 실행하는 역할을 합니다.</p>
<p>위의 프로비저너 스니펫은 <code>example</code> EC2 인스턴스에 할당된 Elastic IP를 <code>ip_address.txt</code> 파일로 출력합니다.</p>
<h4 id="프로비저너-실행하기-Running-Provisioners"><a href="#프로비저너-실행하기-Running-Provisioners" class="headerlink" title="프로비저너 실행하기 (Running Provisioners)"></a>프로비저너 실행하기 (Running Provisioners)</h4><p>프로비저너들은 리소스가 생성될때만 동작합니다.<br>이미 실행중인 서버에 대해 구성을 관리하고 소프트웨어를 변경하기 위해 프로비저너를 사용하는 것은 올바르지 않습니다.<br>그냥 서버를 부트스트랩(bootstrap)하는 방법이라고 생각하세요.</p>
<p>서버에 대한 구성 관리 (configuration management)가 필요하다면,<br><strong>진짜</strong> 구성 관리 솔루션을 실행시키기 위한 수단으로 Terraform 프로비저닝을 사용하세요!</p>
<p>기존에 생성한 인프라가 제거되었는지 다시 한번 확인하고, <code>terraform apply</code> 명령을 실행하세요:</p>
<img src="/2016/12/19/Terraform-101/terraform-apply-with-provisoner.png" alt="terraform apply (with local-exec provisioner)" title="terraform apply (with local-exec provisioner)">
<p>짠! Terraform이 EC2 인스턴스를 생성하고, <code>local-exec</code> 프로비저너가 동작하는 것을 확인하실 수 있습니다.</p>
<p>Terraform은 프로비저너들의 모든 출력을 콘솔에 표시하지만, 이번에는 redirection으로 인해 출력 결과가 보이지 않을 겁니다.<br>그래서 <code>ip_address.txt</code> 파일을 확인해 <code>local-exec</code> 프로비저너가 잘 동작했는지 검증해보도록 하죠.</p>
<p><code>cat ip_address.txt</code> 명령과 <code>terraform show | grep ip</code>  명령을 각각 실행해보고, 결과를 비교해보세요:</p>
<img src="/2016/12/19/Terraform-101/terraform-provisoner-local-exec-result.png" alt="local-exec 프로비저너 검증" title="local-exec 프로비저너 검증">
<p>우리가 요구한대로, 해당 Elastic IP의 Public IP가 해당 텍스트 파일에 잘 들어간 것을 확인할 수 있습니다!</p>
<h4 id="실패한-프로비저너와-더럽혀진-리소스-Failed-Provisioners-and-Tainted-Resources"><a href="#실패한-프로비저너와-더럽혀진-리소스-Failed-Provisioners-and-Tainted-Resources" class="headerlink" title="실패한 프로비저너와 더럽혀진 리소스 (Failed Provisioners and Tainted Resources)"></a>실패한 프로비저너와 더럽혀진 리소스 (Failed Provisioners and Tainted Resources)</h4><p>만일 리소스는 성공적으로 만들었지만 프로비저닝이 실패한다면, Teraform은 에러를 뱉고 해당 리소스를 <code>tainted</code> (더럽혀진 리소스)로 표기할 것입니다.</p>
<p><code>tainted</code> 상태로 표시되는 리소스는 물리적으론 생성된 상태이지만, 프로비저닝이 실패했기 때문에 사용하기에 안전하다고 여길수 없습니다.</p>
<p>프로비저닝이 실패한 상태에서 (리소스가 <code>tainted</code> 상태일 때) 여러분들이 다음 실행 계획 (execution plan)을 생성한다면 (<code>terraform plan</code> 명령을 실행한다면),<br>Terraform은 해당 리소스가 사용하기에 안전하다고 개런티 할 수 없기 때문에 프로비저닝에 실패한 해당 리소스에 대해 프로비저닝을 다시 시도하지 않습니다.<br>대신 해당 <code>tainted</code> 상태의 리소스를 삭제하고 다시 리소스를 생성한 뒤 프로비저닝을 다시 시도합니다.</p>
<p>Terraform은 또한 <code>apply</code> 단계에서 프로비저닝 실패시 자동으로 작업한 내용을 롤백(rollback)하고 해당 리소스를 제거하지 않습니다.<br>그냥 <code>tainted</code> 상태로 마크만 해 둘것입니다.<br>왜냐하면, 실행 계획 (Execution Plan)에서 생성한 계획은 리소스를 ‘생성’ 한다는 것이었지, ‘삭제’ 하는건 아니었기 때문입니다.<br>만약 롤백을 위해 리소스를 ‘삭제’하게 된다면, 이는 실행 계획의 존재 목적에 반하게 되는 것이기도 합니다.</p>
<p>대신 만약 여러분이 <code>tainted</code> 상태의 리소스가 존재하는 상태에서 새로운 실행 계획을 만든다면 (<code>terraform plan</code> 명령을 실행한다면),<br>새롭게 만들어진 실행 계획에서는 깨끗한 상태를 위해서 <code>tainted</code> 상태의 해당 리소스를 삭제하도록 할 것입니다.</p>
<h4 id="다음"><a href="#다음" class="headerlink" title="다음"></a>다음</h4><p>프로비저닝은 인스턴스를 부트스트랩(bootstrap)이 가능하게 하기 때문에 중요합니다.</p>
<p>다시 한번 말씀드리지만, Terraform에서의 프로비저닝은 구성 관리(configuration management)를 대체하는 위한 것이 아닙니다.<br>그냥 머신을 처음 쓰기 위해 부트스트랩(bootstrap)하는거에요.</p>
<p>여러분들이 구성 관리(configuration management)를 사용한다면,<br>Terraform에서의 프로비저닝은 구성 관리 도구(configuration management tool)를 부트스트랩(bootstrap) 하기 위한 수단으로 사용하셔야 합니다.</p>
<p>다음 섹션에서 우리는 설정을 파라미터화(parameterize) 하기 위해 변수(variable)를 알아볼 것입니다.</p>
<h2 id="입력-변수-Input-Variables"><a href="#입력-변수-Input-Variables" class="headerlink" title="입력 변수 (Input Variables)"></a>입력 변수 (Input Variables)</h2><p>여러분들은 유용한 설정들을 만들기 위한 Terraform 지식을 충분히 얻었습니다.<br>하지만 우리는 아직도 액세스 키 (Access Key), AMI와 같은 정보를 설정파일에 직접 기입(hard-coding)해야 합니다.</p>
<p>Terraform 설정을 공유할 수 있고, 버전관리 할 수 있게하려면, 우리는 설정을 ‘파라미터화’ (parameterize) 해야합니다.<br>이번 섹션에서는 이를 가능하게하는 입력 변수에 대해 소개할 것입니다.</p>
<h4 id="변수-정의하기-Defining-Variables"><a href="#변수-정의하기-Defining-Variables" class="headerlink" title="변수 정의하기 (Defining Variables)"></a>변수 정의하기 (Defining Variables)</h4><p>첫번째로 우리가 만들었던 설정 파일에서 AWS 액세스 키 (access key), 비밀 키 (secret key), 그리고 리전 정보를 변수들로 뽑아내 봅시다.</p>
<p><code>example.tf</code> 설정 파일을 만들었던 디렉토리에서 아래 내용을 <code>variables.tf</code> 파일로 저장하세요.</p>
<blockquote>
<p>참고: Terraform은 작업 디렉토리 (Working directory) 내의 모든 <code>.tf</code> 파일을 불러오기 때문에, 파일명은 원하는 이름을 써도 됩니다. 여기선 그냥 편의를 위해서 <code>variables.tf</code>를 쓸 뿐입니다.</p>
</blockquote>
<script src="https://gist.github.com/mooyoul/d28993544eb0bec8bd939c7a8af21edf.js"></script>

<p>위 스니펫은 Terraform 환경설정 내에 세개의 변수를 정의합니다.<br>처음 두 변수(access_key, secret_key)들은 빈 블럭(<code>{}</code>)을 가지고 있고,<br>세번째 변수는 기본값(<code>default = &quot;ap-northeast-2&quot;</code>)을 설정했습니다.</p>
<p>만약 기본값이 설정되어 있으면, 해당 변수는 선택항목(optional) 입니다.<br>반대로 기본값이 설정되어 있지 않으면, 해당 변수는 필수항목(required)가 되겠죠.</p>
<p>이 상태에서 <code>terraform plan</code> 명령을 실행하면, 아래 화면처럼 Terraform이 할당되지 않은 변수에 입력할 값을 물어볼 것입니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-asking-variable.png" alt="terraform plan 명령 실행시 할당되지 않은 값에 대한 질문" title="terraform plan 명령 실행시 할당되지 않은 값에 대한 질문">
<h4 id="환경설정에서-변수-사용하기-Using-Variables-in-Configuration"><a href="#환경설정에서-변수-사용하기-Using-Variables-in-Configuration" class="headerlink" title="환경설정에서 변수 사용하기 (Using Variables in Configuration)"></a>환경설정에서 변수 사용하기 (Using Variables in Configuration)</h4><p>이번엔 AWS Provider 설정을 다음과 같이 변경하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">provider &quot;aws&quot; &#123;</div><div class="line">  access_key = &quot;$&#123;var.access_key&#125;&quot;</div><div class="line">  secret_key = &quot;$&#123;var.secret_key&#125;&quot;</div><div class="line">  region     = &quot;$&#123;var.region&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의  <code>example.tf</code> 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/a68903a8d7cb5dc747b70cf201b47677.js"></script>

<p>위 스니펫은 더 많은 템플릿 표기법(interpolations)을 사용합니다.<br>이전에 리소스를 참조했던 것과는 다르게, 이번에는 <code>var.</code> 접두사를 사용합니다.<br>이는 Terraform에게 변수에 접근하려는 것임을 알려주게 됩니다.<br>즉, 위 스니펫은 지정한 변수를 사용해 AWS Provider를 구성할 수 있도록 합니다.</p>
<h4 id="변수에-값-할당하기-Assigning-Variables"><a href="#변수에-값-할당하기-Assigning-Variables" class="headerlink" title="변수에 값 할당하기 (Assigning Variables)"></a>변수에 값 할당하기 (Assigning Variables)</h4><p>변수에 값을 할당하는 방법은 여러가지 방법이 있습니다.<br>아래에서 소개하는 각 방법들은 어떤 순서로 변수의 값을 선택되는지에 대한 순서이기도 합니다.</p>
<p>즉, 아래는 내림차순으로 된 변수를 선택할 때 고려되는 우선순위입니다 (아래로 갈수록 우선순위 낮음)</p>
<h5 id="명령줄-플래그-Command-line-flags"><a href="#명령줄-플래그-Command-line-flags" class="headerlink" title="명령줄 플래그 (Command-line flags)"></a>명령줄 플래그 (Command-line flags)</h5><p>여러분은 명령줄(command-line)에서 <code>-var</code> 플래그를 통해 변수의 값을 직접 할당하실 수 있습니다.<br><code>apply</code>, <code>plan</code>, <code>refresh</code>와 같이 환경설정을 읽는 Terraform의 명령이라면 <code>-var</code> 플래그를 사용할 수 있습니다.</p>
<p>아래는 명령줄 플래그로 변수의 값을 할당하는 예제입니다:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ terraform plan \</div><div class="line">  -var <span class="string">'access_key=foo'</span> \</div><div class="line">  -var <span class="string">'secret_key=bar'</span></div></pre></td></tr></table></figure>
<p>다만 이 방법으로 변수에 값을 할당한다면 해당 값들은 저장되지 않기 때문에, Terraform의 명령들을 실행할때마다 반복해서 입력해야만 합니다.</p>
<h5 id="파일에서-읽기-From-a-file"><a href="#파일에서-읽기-From-a-file" class="headerlink" title="파일에서 읽기 (From a file)"></a>파일에서 읽기 (From a file)</h5><p>변수의 값들을 쭉 보존하고 싶다면, 파일을 하나 만들어서 안에 값들을 집어넣는 방법을 써도 됩니다.<br>아래처럼 <code>terraform.tfvars</code> 이름을 가진 파일을 만들기만 하면 됩니다:</p>
<script src="https://gist.github.com/mooyoul/339f994caf90f9e776e5e9d2fbb71382.js"></script>

<p>만약 현재 작업 디렉토리에 <code>terraform.tfvars</code> 파일이 존재한다면,<br>Terraform은 자동으로 해당 파일을 읽어 변수에 값을 할당합니다.</p>
<p>만약 변수 값을 가진 파일이 <code>terraform.tfvars</code>가 아니라면,<br>여러분은 <code>-var-file</code> 플래그를 사용해 직접 읽어올 파일을 지정할 수 있습니다.</p>
<p>또한 이 파일은 이전에 Terraform 설정 파일 (<code>.tf</code>)과 동일하게 HCL(Hashicorp Configuration Language)를 사용하고,<br>Terraform 설정 파일처럼 JSON으로도 작성해서 사용하실 수 있습니다.</p>
<p>Terraform은 사용자 아이디 (username)과 비밀번호를 버전 관리 시스템에 저장하는것을 권장하지 않습니다.<br>하지만, 여러분들은 로컬에 비밀 변수 파일(secret variables file)을 만들고 <code>-var-file</code> 플래그를 통해 사용할 수 있습니다.<br>그리고 한 명령에서 복수개의 <code>-var-file</code> 플래그를 사용할 수 있습니다.</p>
<p>가령 버전 관리 시스템에 어떤건 체크인되고 어떤건 체크인되지 않는 상황이라면 다음과 같을 것입니다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ terraform plan \</div><div class="line">  -var-file=&quot;secret.tfvars&quot; \</div><div class="line">  -var-file=&quot;production.tfvars&quot;</div></pre></td></tr></table></figure>
<h5 id="환경변수에서-읽기-From-environment-variables"><a href="#환경변수에서-읽기-From-environment-variables" class="headerlink" title="환경변수에서 읽기 (From environment variables)"></a>환경변수에서 읽기 (From environment variables)</h5><p>Terraform은 변수의 값을 찾기 위해 <code>TF_VAR_${name}</code> 형식의 이름을 가진 환경변수 또한 읽을 것입니다.<br>예를 들면, <code>TF_VAR_access_key</code> 라는 이름의 환경변수가 존재한다면 Terraform은 <code>access_key</code> 라는 이름의 변수의 값으로 해당 환경변수의 값을 할당합니다.<br>(<code>TF_VAR_access_key=foo</code> 인 경우 <code>access_key</code>의 값으로 <code>foo</code> 할당)</p>
<blockquote>
<p>참고: 환경변수는 오직 문자열 형식으로만 변수 값을 할당합니다.<br>리스트(List)와 맵(Map) 타입의 변수을 할당하고 싶다면, 다른 매커니즘을 사용해 값을 할당해야 합니다.</p>
</blockquote>
<h5 id="UI-입력-UI-Input"><a href="#UI-입력-UI-Input" class="headerlink" title="UI 입력 (UI Input)"></a>UI 입력 (UI Input)</h5><p>만약 여러분이 아무것도 하지 않고 (값 할당 없이) <code>terraform plan</code> 명령이나 <code>terraform plan</code> 명령을 실행한다면,<br>아래와 같이 Terraform은 사용자에게 값을 입력하도록 물어볼 것입니다. </p>
<p>이전에 언급했듯, 이 방법은 값이 저장되지 않습니다. 하지만 Terraform을 처음 사용하는 사용자에게는 좋은 사용자 경험이 될 것입니다.</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-asking-variable.png" alt="terraform plan 명령 실행시 할당되지 않은 값에 대한 질문" title="terraform plan 명령 실행시 할당되지 않은 값에 대한 질문">
<blockquote>
<p>참고: UI 입력은 환경변수와 동일하게 오직 문자열 형식으로만 변수 값을 할당합니다.<br>리스트(List)와 맵(Map) 타입의 변수을 할당하고 싶다면, 다른 매커니즘을 사용해 값을 할당해야 합니다.</p>
</blockquote>
<h5 id="변수-기본값-Variable-Defaults"><a href="#변수-기본값-Variable-Defaults" class="headerlink" title="변수 기본값 (Variable Defaults)"></a>변수 기본값 (Variable Defaults)</h5><p>만약 위에서 소개한 방법 중 그 어떤 곳에서도 변수의 값을 할당하는 곳이 없고, 정의한 변수가 기본값을 가지고 있다면 해당 기본값을 변수에 할당합니다.</p>
<h4 id="리스트-Lists"><a href="#리스트-Lists" class="headerlink" title="리스트 (Lists)"></a>리스트 (Lists)</h4><p>리스트는 명시적으로도 정의할 수 있고 암묵적으로도 정의할 수 있습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># brackets 표기를 사용해 암묵적으로 리스트 타입 정의</div><div class="line">variable &quot;cidrs&quot; &#123; default = [] &#125;</div><div class="line"></div><div class="line"># 리스트 타입 명시</div><div class="line">variable &quot;cidrs&quot; &#123; type = &quot;list&quot; &#125;</div></pre></td></tr></table></figure>
<p>여러분들은 <code>terraform.tfvars</code> 파일에서 리스트의 값들을 할당하실 수 있습니다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cidrs = [ &quot;10.0.0.0/16&quot;, &quot;10.1.0.0/16&quot; ]</div></pre></td></tr></table></figure>
<h4 id="맵-Maps"><a href="#맵-Maps" class="headerlink" title="맵 (Maps)"></a>맵 (Maps)</h4><p>우리는 기존 환경설정 내의 민감한 정보들(API Key나 Secret Key 같은)을 변수를 사용하도록 교체했습니다.<br>하지만, AMI의 경우에는 아직까지 직접 기입하고 있죠.<br>불행하게도, AMI는 사용중인 리전에 따라 지정되어야 합니다. (서울 리전에서의 Ubuntu 16.04 LTS AMI와 버지니아 리전의 Ubuntu 16.04 LTS AMI의 AMI ID가 다르거든요)</p>
<p>한가지 옵션으로 그냥 유저에게 리전에 적합한 AMI를 직접 입력하도록 묻는 것이 있겠지만, Terraform은 맵(Map)을 사용해 그거보다 더 나은 방법으로 문제를 해결할 수 있습니다.    </p>
<p>맵(Map)은 테이블에서 특정 키로 값을 찾아 변수에 할당하기 위한 방법입니다.<br>아래 예제는 이를 정말 잘 보여줍니다. 우리의 AMI들을 맵으로 추출하고 <code>us-west-2</code> 리전을 지원해보도록 만들어 봅시다.</p>
<p>다음 내용을 <code>variables.tf</code> 파일에 추가하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">variable &quot;amis&quot; &#123;</div><div class="line">  type = &quot;map&quot;</div><div class="line">  default = &#123;</div><div class="line">    ap-northeast-2 = &quot;ami-983ce8f6&quot;</div><div class="line">    us-west-2 = &quot;ami-06b94666&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후 <code>variables.tf</code> 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/13e4241125cd98dd2ff9cc1fb8054127.js"></script>


<p>Map 타입의 변수는 명시적으로 정의할 수 있고,<br>아니면 기본 값에 Map 타입의 값을 지정함으로써 해당 변수의 타입이 맵이라는 것을 알려 암묵적으로 정의할수도 있습니다.<br>위 예제에서는 두 경우 모두를 포함합니다.</p>
<p>자, 그럼 <code>example.tf</code>의 <code>aws_instance</code> 리소스를 다음처럼 변경하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">resource &quot;aws_instance&quot; &quot;example&quot; &#123;</div><div class="line">  ami           = &quot;$&#123;lookup(var.amis, var.region)&#125;&quot;</div><div class="line">  instance_type = &quot;t2.micro&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 <code>example.tf</code>의 코드는 다음과 같습니다:</p>
<script src="https://gist.github.com/mooyoul/2f16311eab27fa5cb0efb039e6b6a86a.js"></script>

<p>이번에 새로운 방식의 템플릿 표기(interpolation)를 보실 겁니다. 바로 함수 호출이죠.<br><code>lookup</code> 함수는 동적으로 맵의 특정 키의 값을 찾아봅니다.<br>위 스니펫 기준으로는 <code>var.amis</code> 맵에서 <code>var.region</code>의 값을 키로 사용하여 값을 찾아봅니다.</p>
<p>지금 위 예제에서는 사용하지 않지만, <code>${var.amis[&quot;ap-northeast-2&quot;]}</code>를 통해 정적 참조도 가능한 것을 알아두세요.</p>
<h4 id="맵-할당하기-Assigning-Maps"><a href="#맵-할당하기-Assigning-Maps" class="headerlink" title="맵 할당하기 (Assigning Maps)"></a>맵 할당하기 (Assigning Maps)</h4><p>우리는 위에서 기본 값을 정의했지만, 맵 또한 <code>-var</code> 와 <code>-var-file</code> 플래그를 통해 맵에 대한 값을 할당할 수 있습니다.</p>
<p>예를 들면 다음과 같습니다:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ terraform plan -var &apos;amis=&#123; ap-northeast-2 = &quot;foo&quot;, us-west-2 = &quot;bar&quot; &#125;&apos;</div></pre></td></tr></table></figure>
<blockquote>
<p>참고: <code>-var</code> 플래그를 통해 맵을 할당할 수 있지만,<br>할당하려는 해당 변수의 기본값을 <code>{}</code>으로 설정해 타입을 암시적으로 설정하거나 <code>type = map</code>을 통해 명시적으로 타입을 정의하여야 합니다.<br>그렇게 하지 않으면, Terraform은 문자열 타입의 변수로 간주하기 때문에 에러를 출력할 것입니다.</p>
</blockquote>
<p>아래는 파일을 파일에서 맵을 정의하고, 맵의 값을 정의하고, 맵을 조회해보는 예제입니다. 먼저 변수를 정의하는 것부터 시작하죠.<br>아직 <code>example.tf</code> 파일이 있는 디렉토리에 계시다면, <code>map-playground</code> 라는 이름의 새로운 디렉터리를 생성하고<br>해당 디렉토리로 들어간 후 변수를 정의하기 위해 아래 내용으로 <code>variables.tf</code> 파일을 새로 만들어봅시다.<br>(이전에도 말씀드렸듯이 Terraform은 현재 작업 디렉토리 (Working directory)내의 모든 <code>.tf</code> 파일을 찾아서 불러들이기 떄문에, 동일한 디렉터리에 새로 설정파일을 생성하게되면 이전 예제와 설정이 섞일 수 있습니다. 이를 방지하기 위해 디렉토리를 새로 만드는 것입니다.) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">variable &quot;region&quot; &#123;&#125;</div><div class="line">variable &quot;amis&quot; &#123;</div><div class="line">  type = &quot;map&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>그리고, 변수를 정의했으니 값을 할당해줘야겠죠? 이번에는 맵에 대한 값을 파일로 저장합니다.<br>다음 내용을 <code>terraform.tfvars</code> 파일로 저장하세요.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">amis = &#123;</div><div class="line">  ap-northeast-2 = &quot;ami-983ce8f6&quot;</div><div class="line">  us-west-2 = &quot;ami-def456&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>마지막으로, 다음 내용을 <code>output.tf</code> 파일로 저장하세요.<br>아래 스니펫은 <code>lookup</code> 함수를 사용해 <code>amis</code> 맵에서 <code>region</code> 변수의 값을 키로 사용하여 값을 찾아 출력할 것입니다.<br><code>output</code>이 무얼 뜻하는지 더 궁금하시겠지만, 일단은 조금만 참으세요. 다음 섹션에서 설명할겁니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">output &quot;ami&quot; &#123;</div><div class="line">  value = &quot;$&#123;lookup(var.amis, var.region)&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>자, 그럼 <code>terraform apply -var region=us-west-2</code> 명령을 실행해보세요:</p>
<img src="/2016/12/19/Terraform-101/terraform-map.png" alt="region에 따라 ami가 다른걸 보세요!" title="region에 따라 ami가 다른걸 보세요!">
<p>region에 따라 ami가 다르게 출력되는 것을 확인하실 수 있습니다!</p>
<h4 id="다음-1"><a href="#다음-1" class="headerlink" title="다음"></a>다음</h4><p>Terraform은 여러분들의 설정을 파라미터화하기 위한 변수를 제공합니다.<br>맵은 여러분들이 조건에 따라 테이블의 값들을 찾아볼 수 있도록 할 것입니다.</p>
<p>다음 장부터는 위에서 맵을 사용해보기 위해 새롭게 만든 디렉토리와 환경설정들을 더이상 필요로 하지 않습니다.<br><code>map-playground</code> 디렉토리와 디랙토리 내의 모든 파일들을 삭제하고,<br>이전에 EC2 인스턴스와 Elastic IP를 정의했던 Terraform 설정파일이 있는 디렉토리로 다시 되돌아가세요.</p>
<h2 id="출력-변수-Output-Variables"><a href="#출력-변수-Output-Variables" class="headerlink" title="출력 변수 (Output Variables)"></a>출력 변수 (Output Variables)</h2><p>이전 섹션에서 입력 변수(input variables)를 Terraform 구성 설정을 파라미터화(parameterize) 하는 방법으로 소개했습니다.<br>이번 섹션에서는 출력 변수(output variables)를 Terraform 유저가 데이터를 쉽게 질의하고 볼 수 있도록 관리하는 방법으로 소개할 것입니다.</p>
<p>잠재적으로 복잡한 인프라를 만들때, Terraform은 여러분들의 모든 리소스에 대한 100~1000개의 속성 값들을 저장합니다.<br>하지만 Terraform를 사용하는 유저는 로드 밸런서 IP, VPN 주소와 같은 오직 몇가지의 중요한 속성 값만 관심을 가지고 있을 것입니다.</p>
<p>출력 변수는 Terraform에게 어떤 정보가 중요한지 알리는 방법입니다.<br>출력 변수로 지정한 데이터는 <code>terraform apply</code> 명령을 실행하면 출력되고, <code>terraform output</code> 명령을 사용해 질의할 수도 있습니다.</p>
<h4 id="출력-변수-정의하기-Defining-Outputs"><a href="#출력-변수-정의하기-Defining-Outputs" class="headerlink" title="출력 변수 정의하기 (Defining Outputs)"></a>출력 변수 정의하기 (Defining Outputs)</h4><p>이전에 우리가 생성한 Elastic IP 리소스의 공인 IP(Public IP)를 보기 위해 출력 변수를 정의해봅시다.</p>
<p><code>example.tf</code> 파일을 열어서 아래 내용을 추가하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">output &quot;ip&quot; &#123;</div><div class="line">    value = &quot;$&#123;aws_eip.ip.public_ip&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후의 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/3622099b93a14fe660291fc6a86614a9.js"></script>

<p>위 스니펫은 <code>ip</code>라는 이름의 출력 변수를 정의합니다. <code>value</code> 필드는 해당 출력 변수가 어떤 값을 가질지를 정의하고, 거의 항상 하나 이상의 템플릿 표기법(interpolations)들을 가지고 있습니다. 대부분의 값들은 동적이기 때문이죠.<br>이번 경우에는 Elastic IP 리소스의 <code>public_ip</code> 속성을 값으로 출력할 것입니다.</p>
<p>여러개의 출력 변수를 정의하기 위해 복수의 <code>output</code> 블럭을 사용할 수도 있습니다.</p>
<h4 id="출력-변수-확인하기-Viewing-Outputs"><a href="#출력-변수-확인하기-Viewing-Outputs" class="headerlink" title="출력 변수 확인하기 (Viewing Outputs)"></a>출력 변수 확인하기 (Viewing Outputs)</h4><p>출력 변수에 값을 채워넣기 위해 <code>terraform apply</code> 명령을 실행해보세요. 출력 변수를 정의했다면 반드시 한번 해야 합니다.</p>
<p>아마 명령을 실행한 결과가 이전과 조금 다를겁니다.<br>이렇개 실행 결과의 끝 부분을 보시면 여러분이 지정한 출력 변수를 확인하실 수 있죠:</p>
<img src="/2016/12/19/Terraform-101/terraform-apply-with-output-variables.png" alt="terraform apply" title="terraform apply">
<p><code>terraform apply</code> 명령은 출력 변수의 값들을 강조해 보여줍니다.</p>
<p>또한 여러분들은 <code>terraform apply</code> 명령을 수행해 출력 변수에 값을 할당한 이후부터 <code>terraform output [NAME]</code> 명령을 사용해 출력 변수의 값을 질의할 수 있습니다.</p>
<p>별도로 출력 변수의 이름을 인자로 넘기지 않은 경우 (<code>terraform output</code> 명령을 실행한 경우), Terraform은 모든 출력 변수의 이름과 값을 출력할 것입니다.<br>반대로 출력 변수의 이름을 인자로 넘기는 경우 (<code>terraform output ip</code>), Teraform은 해당 이름의 출력 변수의 값만을 출력합니다.</p>
<p><code>terraform output</code>, <code>terraform output ip</code> 명령을 각각 실행해 결과를 비교해보세요:</p>
<img src="/2016/12/19/Terraform-101/terraform-output.png" alt="terraform output" title="terraform output">
<p>이 명령은 스크립트(e.g. 쉘 스크립트)에서 출력 변수의 값을 추출할 때 유용하게 사용할 수 있습니다.</p>
<h4 id="다음-2"><a href="#다음-2" class="headerlink" title="다음"></a>다음</h4><p>여러분들은 이제 어떻게 Terraform 환경설정을 입력 변수(input variables)로 파라미터화하고,<br>출력 변수(output variables)로 중요한 데이터를 추출하고, 프로비저너(provisioners)를 사용해 리소스를 부트스트랩(bootstrap)하는지 알겁니다.</p>
<p>다음 섹션에서 우리는 어떻게 모듈(modules)을 사용하고, 구조에 유용한 추상화, 그리고 Terraform 환경설정을 재사용 하는 방법을 알아볼 것입니다.</p>
<p>그동안 가이드를 따라오면서 만들고 수정했던 Terraform 환경설정 파일들과 리소스는 더이상 사용하지 않습니다.<br><code>terraform destroy</code> 명령을 통해 해당 리소스들을 모두 삭제하시고, 모든 환경설정 파일 또한 삭제하세요. 다음 섹션에서 새롭게 Terraform 환경설정을 생성할 것입니다.</p>
<h2 id="모듈-Modules"><a href="#모듈-Modules" class="headerlink" title="모듈 (Modules)"></a>모듈 (Modules)</h2><p>여기까지는 우리는 Terraform을 환경설정을 직접 수정하여 Terraform을 구성했습니다.<br>인프라가 성장함에 따라, 이 방법은 몇가지 문제를 가지고 있습니다: 인프라를 구성하는 구조(organization)의 부재, 재사용성의 부재, 그리고 팀을 위한 관리의 어려움.</p>
<p>Terraform의 모듈은 그룹으로 관리되는 Terraform 설정들을 가지고 있는 패키지(self-contained packages of Terraform configurations)입니다.<br>모듈은 재사용한 컴포넌트를 만들고, 구조를 개선시키며, 인프라를 각 부분을 블랙박스로 처리(to treat pieces of infrastructure as a black box.) 할 수 있습니다.</p>
<p>이 섹션은 모듈을 사용하는 기초를 다룹니다. 모듈을 작성하는 방법은 <a href="https://www.terraform.io/docs/modules/" target="_blank" rel="external">모듈 문서</a>에서 상세히 다루고 있으니 관심이 있으시다면 해당 문서를 참고하시기 바랍니다.</p>
<blockquote>
<p>주의: 이 엑션의 예제들은 AWS 프리 티어에 적용되지 않습니다.<br>조금의 요금이라도 지불할 의사가 없으시다면, 이 섹션의 예제를 실행하지 마세요.</p>
</blockquote>
<h4 id="모듈-사용하기-Using-Modules"><a href="#모듈-사용하기-Using-Modules" class="headerlink" title="모듈 사용하기 (Using Modules)"></a>모듈 사용하기 (Using Modules)</h4><p>아래 예제에서는 완전한 <a href="https://www.consul.io/" target="_blank" rel="external">Consul</a> 클러스터를 구성하는 <a href="https://github.com/hashicorp/consul/tree/master/terraform" target="_blank" rel="external">Consul Terraform 모듈</a>을 사용할 것입니다.  </p>
<p>아래 내용으로 새롭게 Terraform 환경설정 파일을 만드세요.<br>저는 <code>consul-terraform.tf</code> 으로 저장했습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">variable &quot;access_key&quot; &#123;&#125;</div><div class="line">variable &quot;secret_key&quot; &#123;&#125;</div><div class="line">variable &quot;region&quot; &#123;</div><div class="line">  default = &quot;ap-northeast-2&quot;</div><div class="line">&#125;</div><div class="line">variable &quot;key_name&quot; &#123;&#125;</div><div class="line">variable &quot;key_path&quot; &#123;&#125;</div><div class="line"></div><div class="line">provider &quot;aws&quot; &#123;</div><div class="line">  access_key = &quot;$&#123;var.access_key&#125;&quot;</div><div class="line">  secret_key = &quot;$&#123;var.secret_key&#125;&quot;</div><div class="line">  region     = &quot;$&#123;var.region&#125;&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">module &quot;consul&quot; &#123;</div><div class="line">    # source 속성의 원본 값은 아래와 같으나, </div><div class="line">    # 현재 Consul의 Terraform의 AWS 템플릿에 서울 리전 (ap-northeast-2) AMI가 정의되지 않아</div><div class="line">    # AWS 서울 리전으로 사용할 수 없는 문제가 있어 fork한 버전을 대신 사용합니다.</div><div class="line">    # Consul PR URL: https://github.com/hashicorp/consul/pull/2620</div><div class="line">    # 위 PR이 머지된다면, 아래 코드를 사용하셔도 무방합니다.</div><div class="line">    #</div><div class="line">    # source = &quot;github.com/hashicorp/consul/terraform/aws&quot;</div><div class="line"></div><div class="line">    source = &quot;github.com/mooyoul/consul?ref=tf-module-support-aws-seoul//terraform/aws&quot;</div><div class="line">    key_name = &quot;$&#123;var.key_name&#125;&quot;</div><div class="line">    key_path = &quot;$&#123;var.key_path&#125;&quot;</div><div class="line">    region = &quot;$&#123;var.region&#125;&quot;</div><div class="line">    servers = &quot;3&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>전체 코드는 다음과 같을 것입니다:</p>
<script src="https://gist.github.com/mooyoul/f71ca268ea8416cc5db212e5153fd136.js"></script>

<blockquote>
<p>참고로 위 <code>provider</code> 블럭은 AWS CLI에서 사용하는 환경변수를 사용한다면 생략할 수 있습니다. 자세한 내용은 <a href="https://www.terraform.io/docs/providers/aws/#argument-reference" target="_blank" rel="external">AWS Provider 문서의 Argument Reference</a>와 <a href="https://www.terraform.io/docs/providers/aws/#environment-variables" target="_blank" rel="external">AWS Provider 문서의 Environment Variables</a>를 참고하세요.<br><strong>중요: 이 Consul 모듈은 기본 VPC를 가지고 있는 AWS 계정을 필요로합니다.</strong></p>
</blockquote>
<p><code>module</code> 블럭은 Terraform에게 모듈을 만들고 관리하도록 알립니다.<br>이전에 봤던 리소스를 정의하는 <code>resource</code> 블럭과 아주 유사하죠.<br>다만 모듈은 리소스와 달리 오직 하나의 논리적 이름 (logical name, 별명으로 생각하시면 됩니다.)만 가지고 있습니다.<br>위 예제에서는 <code>consul</code>이 논리적 이름이 되겠죠.</p>
<p><code>module</code> 블럭 내에 정의된 <code>source</code> 속성은 모듈 내 속성중 유일한 필수 항목입니다.<br><code>source</code> 속성은 Terraform에게 어디서 모듈을 받아올 지 알립니다.<br>Terraform은 여러분들을 위해 모듈들을 자동으로 내려받고 관리해줄 것입니다.</p>
<p>위 예제에서는 모듈을 Github에서 가져오지만, Terraform은 Git, Mercurial, HTTP, 그리고 파일 경로와 같은 다양한 소스들에서 모듈을 받아올 수 있습니다.</p>
<p>이외 다른 설정들은 모듈의 인자(parameter) 입니다. 위 예제에서는 변수를 참조하도록 값을 채워 넣었습니다.</p>
<p>여러분들이 모듈을 정의하고 나서 <code>plan</code>이나 <code>apply</code> 같은 명령을 실행하기 위해서 실행 전에 한번은 모듈을 얻어오는(내려받고 설치하는) 과정이 필요할 것입니다.<br><code>terraform get</code> 명령으로 바로 그 작업을 수행할 수 있습니다. 바로 실행해보세요:</p>
<img src="/2016/12/19/Terraform-101/terraform-get.png" alt="terraform get" title="terraform get">
<p>Terraform이 알아서 모듈을 얻어오는 것을 확인하실 수 있습니다.</p>
<p><code>terraform get</code> 명령은 내려받지 않은 모듈들이 있다면, 내려받지 않은 모듈들을 내려받을 것입니다.<br>기본적으로 <code>terraform get</code> 명령은 업데이트를 확인하지 않습니다. 그렇기 때문에 안전하게 (그리고 빠르게) 여러번 실행할 수 있습니다.<br>만약 업데이트를 확인하고 내려받고 싶으시다면 <code>-u</code> 플래그를 사용하시면 됩니다. Golang을 쓰시는 분들은 뭔가 좀 익숙하시죠?</p>
<h4 id="모듈을-계획하고-적용하기-Planning-and-Apply-Modules"><a href="#모듈을-계획하고-적용하기-Planning-and-Apply-Modules" class="headerlink" title="모듈을 계획하고 적용하기 (Planning and Apply Modules)"></a>모듈을 계획하고 적용하기 (Planning and Apply Modules)</h4><p>모듈들을 내려받았다면, 우리는 이제 <code>plan</code> 명령을 통해 계획을 점검하고  <code>apply</code> 명령을 통해 이를 적용해볼 수 있습니다.<br>여러분들이 <code>terraform plan</code> 명령을 실행한다면 다음과 같은 출력을 볼것입니다:</p>
<script type="text/javascript" src="https://asciinema.org/a/9op10q1bklo3lm4g8x85hg5hk.js" id="asciicast-9op10q1bklo3lm4g8x85hg5hk" async></script>

<p>개념적으로 모듈은 블랙박스(block box)처럼 취급되더라도,<br>게획(plan)에서 Terraform은 모듈이 괸리하는 각 리소스를 보여주므로 계획에서 수행하는 작업에 대한 상세한 정보를 볼 수 있습니다.</p>
<p>만약 여러분들이 줄여진 계획(실행계획) 출력을 원하신다면 <code>-module-depth=number</code> 플래그를 사용해 Terraform이 모듈별로 요약을 출력하도록 할 수 있습니다.</p>
<p>예로 <code>terraform plan -module-depth=0</code> 명령을 실행해보면 이전과 다르게 출력이 줄어든 것을 확인할 수 있습니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-plan-module-depth.png" alt="terraform plan -module-depth=0" title="terraform plan -module-depth=0">
<p>다음은 <code>terraform apply</code> 명령을 실행해 모듈을 만들어봅시다.<br>위에서 경고했듯이, 이 Consul 모듈은 AWS 프리티어에 해당하지 않는 리소스를 생성하기 때문에 약간의 비용이 발생하니 참고하시기 바랍니다.</p>
<p>자, 그럼 <code>terraform apply</code> 명령을 실행해봅시다!</p>
<script type="text/javascript" src="https://asciinema.org/a/1y4k4c0971c0ro8knol1jlazt.js" id="asciicast-1y4k4c0971c0ro8knol1jlazt" async></script>

<p>몇분정도만 기다리면, 세개의 서버로 이루어진 Consul 클러스터가 동작하는 것을 얻을 겁니다!<br>Consul이 어떻게 동작하고, Consul을 어떻게 설치하고, 그리고 Consul을 어떻게 클러스터로 구성하는지 아무런 지식을 가지고 있지 않지만,<br>우리는 단 몇분만에 실제로 돌아가는 Consul 클러스터를 만들었습니다. 짱이죠?</p>
<h4 id="모듈-출력-Module-Outputs"><a href="#모듈-출력-Module-Outputs" class="headerlink" title="모듈 출력 (Module Outputs)"></a>모듈 출력 (Module Outputs)</h4><p>위의 서버와 같은 속성을 설정해 모듈을 파라미터화(parameterize)했던 것처럼, 모듈은 정보를 출력 할 수도 있습니다 (리소스에서 정보를 출력했던 것처럼요).</p>
<p>여러분들은 모듈들이 어떤 출력을 지원하는지 알기 위해서 각 모듈드의 코드나 문서를 참조해야합니다만,<br>이 가이드에서는 그냥 여러분들께 Consul 모듈이 구성된 Consul 서버들에 대한 주소 정보를 가지고있는 <code>server_address</code>라는 이름을 가진 출력값을 가지고 있다는걸 알려드릴겁니다.</p>
<p>이 <code>server_address</code>를 참조하기 위해서 일단 출력 변수에 저장해보도록 하겠습니다.<br>모듈 출력은 출력 변수 뿐만 아니라 다른 리소스(Elastic IP 리소스를 구성할 때 EC2 인스턴스의 ID를 참조했던 것 처럼), 다른 Provider를 구성할 때 등 어디에서든지 참조해 사용할 수 있습니다. </p>
<p>이전에 만들었던 <code>consul-terraform.tf</code> 파일에 아래 내용을 추가하세요:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">output &quot;consul_address&quot; &#123;</div><div class="line">    value = &quot;$&#123;module.consul.server_address&#125;&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>변경 후 코드는 다음과 같습니다:</p>
<script src="https://gist.github.com/mooyoul/2dcef697470220df05a362ad1688b7b6.js"></script>


<p>모듈 출력을 참조하기 위한 문법은 아주 친숙할겁니다.<br>문법은 <code>${module.NAME.ATTRIBUTE}</code> 입니다.<br><code>NAME</code>은 전에 우리가 할당한 논리적 이름(logical name)이고,<br><code>ATTRIBUTE</code>는 모듈이 출력하는 속성의 이름입니다. <code>server_address</code>가 이에 해당하겠죠.</p>
<p>여러분들이 <code>terraform apply</code> 명령을 다시 실행한다면 Terraform은 아무런 변경사항을 만들지 않을겁니다만,<br>명령의 실행 결과에서 Consul 서버의 주소를 <code>consul_address</code> 이름의 출력값으로 확인할 수 있을 것입니다:</p>
<img src="/2016/12/19/Terraform-101/terraform-consul.png" alt="terraform apply 실행 후 확인할 수 있는 consul_address 출력" title="terraform apply 실행 후 확인할 수 있는 consul_address 출력">
<h4 id="다음-3"><a href="#다음-3" class="headerlink" title="다음"></a>다음</h4><blockquote>
<p>생성한 Consul 모듈은 이제 더이상 사용하지 않습니다. 필요치 않은 과금을 방지하려면 반드시 <code>terraform destroy</code> 명령을 통해 인프라를 제거하세요!</p>
</blockquote>
<p>어떤 <code>source</code> 종류들을 지원하는지, 어떻게 모듈을 작성하는지 등 모듈에 대한 자세한 정보를 얻기 원하신다면 <a href="https://www.terraform.io/docs/modules/" target="_blank" rel="external">모듈 문서</a>를 참고하세요.</p>
<h2 id="다음-단계들"><a href="#다음-단계들" class="headerlink" title="다음 단계들"></a>다음 단계들</h2><p>여러분들이 Terraform이 유용하다는 것을 알 수 있을뿐만 아니라, 여기서 배운 지식들로 여러분들의 인프라 구축을 향상시킬 수 있기를 바랍니다.</p>
<p>드디어 여러분들은 첫 걸음마를 뗐습니다.<br>더 많은 것들을 배우시고 싶은 분들을 위해 참고할만한 몇가지 링크를 남겨놓으니 참고하시기 바랍니다.</p>
<ul>
<li><a href="https://www.terraform.io/docs/" target="_blank" rel="external">Terraform 문서</a> - Terraform이 어떻게 동작하는지에 대한 기술 상세정보를 포함해 Terraform의 모든 기능들에 대한 자세한 레퍼런스가 담겨 있습니다.</li>
<li><a href="https://www.terraform.io/intro/examples/" target="_blank" rel="external">Terraform 예제</a> - Terraform을 사용하는 완벽한 기능의 구성 파일들이 담겨 있습니다. Terraform으로 어떤 것을 할 수 있는지 더 자세히 알아볼 수 있습니다.</li>
<li><a href="https://www.terraform.io/docs/import/" target="_blank" rel="external">Terraform 불러오기(Import)</a> - Import 문서는 기존 인프라를 Terraform으로 불러오기 위한 내용을 다룹니다.</li>
</ul>
<h2 id="회고"><a href="#회고" class="headerlink" title="회고"></a>회고</h2><p>처음에는 직접 가이드를 써보려고 했는데 생각보다 범위가 넓어 <a href="https://www.terraform.io/intro/getting-started/" target="_blank" rel="external">Terraform의 Getting Started 문서</a>를 한국어로 번역하는것을 기본으로 살을 좀 더 붙였습니다.<br>영어실력이 미천하여 다소 번역이 딱딱하거나 엉성할 수 있습니다 ㅠㅠ</p>
<p>사실 저는 DevOps 엔지니어가 아니라 풀스택 개발자입니다만, 최근에는 서비스를 배포하는 방법이 점점 다양하고 중요해지는 것 같아 DevOps를 열심히 공부하고 있습니다.<br>웹 생태계는 해가 지날수록 눈 깜짝하는 사이에 정말 많은것이 쏟아져나오고 빠르게 변화하고 있는데, DevOps 역시 정말 빠르게 변화하고 진화하는 것 같네요. 흥미진진합니다.</p>
<p><a href="https://www.hashicorp.com/#open-source-tools" target="_blank" rel="external">Hashicorp의 다른 제품들</a>, 그리고 <a href="https://www.terraform.io/intro/hashicorp-ecosystem.html" target="_blank" rel="external">그것들을 묶어서 만든 에코시스템</a>인 Atlas도 정말 대단합니다.<br><a href="https://www.hashicorp.com/devops.html" target="_blank" rel="external">Hashicorp - Devops Defined</a>를 보면 목표도 확실한 것 같고요.<br>예전에 Hashicorp의 대표인 <a href="https://github.com/mitchellh" target="_blank" rel="external">Mitchell Hashimoto</a>의 인터뷰 기사를 본 적이 있는데, DevOps를 바로잡기 위헤서 Terraform과 같은 도구들을 만들었다고 언급하기도 했죠.</p>
<p>오픈소스 프로젝트들에서 <code>vagrant up</code> 뿐만 아니라 <code>terraform apply</code>도 자주 마주칠 수 있기를 기대해봅니다!</p>
<h2 id="기념으로-남기는-링크"><a href="#기념으로-남기는-링크" class="headerlink" title="기념으로 남기는 링크"></a>기념으로 남기는 링크</h2><ul>
<li><a href="https://github.com/hashicorp/terraform/issues/10943" target="_blank" rel="external">Terraform issue #10943 - website: Broken markdown style on getting started page</a></li>
<li><a href="https://github.com/hashicorp/terraform/pull/10944" target="_blank" rel="external">Terraform PR #10944 - website: Fix broken markdown style on ‘lists’ section of variables page</a></li>
<li><a href="https://github.com/hashicorp/terraform/issues/10949" target="_blank" rel="external">Terraform issue #10949 - website: Incorrect description Variable page of Getting Started</a></li>
<li><a href="https://github.com/hashicorp/terraform/pull/10950" target="_blank" rel="external">Terraform PR #10950 - website: Correct unrelated contents on env vars in variables page</a></li>
<li><a href="https://github.com/hashicorp/consul/pull/2620" target="_blank" rel="external">Consul PR #2620 - Add Seoul region to the map for ubuntu</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <ul class="article-meta">
        <li>
          <span class="label">Published Date:</span>
          <a href="/2016/12/19/Terraform-101/" class="article-date">
  <time datetime="2016-12-18T18:24:42.000Z" itemprop="datePublished">2016-12-19</time>
</a>

        </li>
        
          <li>
            <span class="label">Catégorie:</span>
            
  <div class="article-category">
    <a class="article-category-link" href="/categories/devops/">devops</a>
  </div>


          </li>
        
        
          <li>
            <span class="label">Mot-clé:</span>
            
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/devops-terraform-aws-infrastructure-hashicorp/">devops, terraform, aws, infrastructure, hashicorp</a></li></ul>


          </li>
        
        <hr/>
      </ul>
    </footer>
  </div>
  
    
<nav id="article-nav" class="article-nav">
  
    <a href="/2017/02/16/Setting-Timezone-on-AWS-Lambda/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          AWS Lambda에서의 Timezone 설정
        
      </div>
    </a>
  
  
    <a href="/2016/11/06/installing-kiturami-iot-heating-controller/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">귀뚜라미보일러 IoT 컨트롤러 설치기 및 뜯어보기</div>
    </a>
  
</nav>


  
</article>




      </div>
      
    <footer id="footer" class="post-footer footer">
      <hr/>
      <div id="footerContent" class="footer-content">
        <p>init 1 - MooYeol Prescott Lee</p>


      </div>
    </footer>

      

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/typing.js"></script>
<!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-83917556-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->





    </div>
  </body>
</html>
